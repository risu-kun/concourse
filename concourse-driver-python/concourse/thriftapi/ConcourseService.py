#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from .data.ttypes import *
from .shared.ttypes import *
from .exceptions.ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  The interface definition for the Concourse Server API.
  """
  def abort(self, creds, transaction, environment):
    """
    Abort the current transaction and discard any changes that are
    currently staged.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    Calling this method when the driver is not in {@code staging} mode is a
    no-op.
    </p>
    @param record the id of the record in which an attempt is made to add
                    the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @throws exceptions.SecurityException if the {@code creds} don't represent a
            valid session

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValue(self, key, value, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in a new record.

    @param key the field name
    @param value the value to add
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the new record id
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in {@code record}.

    @param key the field name
    @param value the value to add
    @param record the record id where an attempt is made to add the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in each of the {@code records} where it
    doesn't exist.

    @param key the field name
    @param value the value to add
    @param records a list of record ids where an attempt is made to add the
                     data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a mapping from each record id to a boolean that indicates if the
                      data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecord(self, record, creds, transaction, environment):
    """
    List all the changes ever made to {@code record}.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStart(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecord(self, key, record, creds, transaction, environment):
    """
    List all the changes ever made to the {@code key} field in {@code record}.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent change that
                 should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def browseKey(self, key, creds, transaction, environment):
    """
    View the values from all records that are currently stored for {@code key}.

    @param keys the field name
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contain that value in the {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeys(self, keys, creds, transaction, environment):
    """
    View the values from all records that are currently stored for each of the
    {@code keys}.

    @param keys a list of field names
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the set of records that contain that value in the
            {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    """
    View a time series that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def clearRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def clearKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def commit(self, creds, transaction, environment):
    """
    Attempt to permanently commit any changes that are staged in a transaction
    and return {@code true} if and only if all the changes can be applied.
    Otherwise, returns {@code false} and all the changes are discarded.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    This method will return {@code false} if it is called when the driver is
    not in {@code staging} mode.
    </p>

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return {@code true} if all staged changes are committed, otherwise {@code
                         false}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecord(self, record, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in {@code record}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that had at least one value at
    {@code timestamp}.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecords(self, records, creds, transaction, environment):
    """
    For each of the {@code records}, list all of the keys that have at least
    one value.

    @param records a collection of record ids
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys in that record
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStart(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStart(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartstr(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    pass

  def invokePlugin(self, id, method, params, creds, transaction, environment):
    """
    Invoke a Plugin method.

    <p>
    Assuming that there is a plugin distribution that contains a class
    named after {@code id}, and has the specified {@code method}, invoke the
    same with {@code params} and return the result.
    </p>

    @param id the fully qualified name of the plugin class
    @param method the name of the method in {@code clazz} to invoke
    @param params a list of TObjects to pass to {@code method} as args
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the result of the method invocation
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of the arguments are
            invalid

    Parameters:
     - id
     - method
     - params
     - creds
     - transaction
     - environment
    """
    pass

  def login(self, username, password, environment):
    """
    Attempt to authenticate the user identified by the {@code username} and
    {@code password} combination to the specified {@code environment}. If
    successful, establish a new session within the {@code environment} on
    behalf of that user and return an {@link shared.AccessToken}, which is
    required for all subsequent operations.

    <p>
    The AccessToken <em>may</em> expire after a while so clients should be
    prepared to seamlessly login again for active user sessions.
    </p>

    @param username a binary representation of the UTF-8 encoded username
    @param password a binary representation of the UTF-8 encoded password
    @param environment the name of the environment into which to login
    @return an {@link shared.AccessToken} to submit with all subsequent method
            calls
    @throws exceptions.SecurityException if the login is not successful

    Parameters:
     - username
     - password
     - environment
    """
    pass

  def logout(self, token, environment):
    """
    Terminate the session within {@code environment} for the user represented
    by the {@code token}. Afterwards, all other attempts to use {@code token}
    will result in a {@link exceptions.SecurityException} being thrown.

    @param token the {@link shared.AccessToken to expire}
    @param environment the environment of the session represented by the
                       {@code token}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session

    Parameters:
     - token
     - environment
    """
    pass

  def stage(self, token, environment):
    """
    Start a new transaction.
    <p>
    This method will turn on STAGING mode so that all subsequent changes are
    collected in an isolated buffer before possibly being committed to the
    database. Staged operations are guaranteed to be reliable, all or nothing
    units of work that allow correct recovery from failures and provide
    isolation between clients so the database is always in a consistent state.
    </p>
    <p>
    After this method returns, all subsequent operations will be done in
    {@code staging} mode until either #abort(shared.AccessToken) or
    #commit(shared.AccessToken) is called.
    </p>

    @param token
    @param environment
    @return TransactionToken
    @throws TSecurityException

    Parameters:
     - token
     - environment
    """
    pass

  def insertJson(self, json, creds, transaction, environment):
    """
    Parameters:
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def insertJsonRecord(self, json, record, creds, transaction, environment):
    """
    Parameters:
     - json
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def insertJsonRecords(self, json, records, creds, transaction, environment):
    """
    Parameters:
     - json
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    """
    The {@code value} in {@code key} of {@code record} are added
    and removed to be set as exactly the same as the input values

    @param key the field name
    @param record the record id where an attempt is made to add the data
    @param values collection of values to set
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - record
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def inventory(self, creds, transaction, environment):
    """
    Parameters:
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecords(self, records, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    pass

  def findCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    pass

  def findCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def search(self, key, query, creds, transaction, environment):
    """
    Parameters:
     - key
     - query
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    pass

  def pingRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    pass

  def pingRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    """
    Parameters:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment
    """
    pass

  def verifyOrSet(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    pass

  def findOrAddKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    pass

  def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - json
     - creds
     - transaction
     - environment
    """
    pass

  def getServerEnvironment(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    pass

  def getServerVersion(self):
    pass

  def time(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    pass

  def timePhrase(self, phrase, creds, token, environment):
    """
    Parameters:
     - phrase
     - creds
     - token
     - environment
    """
    pass


class Client(Iface):
  """
  The interface definition for the Concourse Server API.
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def abort(self, creds, transaction, environment):
    """
    Abort the current transaction and discard any changes that are
    currently staged.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    Calling this method when the driver is not in {@code staging} mode is a
    no-op.
    </p>
    @param record the id of the record in which an attempt is made to add
                    the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @throws exceptions.SecurityException if the {@code creds} don't represent a
            valid session

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_abort(creds, transaction, environment)
    self.recv_abort()

  def send_abort(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('abort', TMessageType.CALL, self._seqid)
    args = abort_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_abort(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = abort_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return

  def addKeyValue(self, key, value, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in a new record.

    @param key the field name
    @param value the value to add
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the new record id
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValue(key, value, creds, transaction, environment)
    return self.recv_addKeyValue()

  def send_addKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValue', TMessageType.CALL, self._seqid)
    args = addKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValue failed: unknown result")

  def addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in {@code record}.

    @param key the field name
    @param value the value to add
    @param record the record id where an attempt is made to add the data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_addKeyValueRecord()

  def send_addKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValueRecord', TMessageType.CALL, self._seqid)
    args = addKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecord failed: unknown result")

  def addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Append {@code key} as {@code value} in each of the {@code records} where it
    doesn't exist.

    @param key the field name
    @param value the value to add
    @param records a list of record ids where an attempt is made to add the
                     data
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a mapping from each record id to a boolean that indicates if the
                      data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_addKeyValueRecords(key, value, records, creds, transaction, environment)
    return self.recv_addKeyValueRecords()

  def send_addKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('addKeyValueRecords', TMessageType.CALL, self._seqid)
    args = addKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = addKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addKeyValueRecords failed: unknown result")

  def auditRecord(self, record, creds, transaction, environment):
    """
    List all the changes ever made to {@code record}.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_auditRecord(record, creds, transaction, environment)
    return self.recv_auditRecord()

  def send_auditRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecord', TMessageType.CALL, self._seqid)
    args = auditRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecord failed: unknown result")

  def auditRecordStart(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStart(record, start, creds, transaction, environment)
    return self.recv_auditRecordStart()

  def send_auditRecordStart(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStart', TMessageType.CALL, self._seqid)
    args = auditRecordStart_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStart failed: unknown result")

  def auditRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List all the changes made to {@code record} since {@code start}
    (inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
                     revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartstr(record, start, creds, transaction, environment)
    return self.recv_auditRecordStartstr()

  def send_auditRecordStartstr(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartstr', TMessageType.CALL, self._seqid)
    args = auditRecordStartstr_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstr failed: unknown result")

  def auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartEnd(record, start, tend, creds, transaction, environment)
    return self.recv_auditRecordStartEnd()

  def send_auditRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartEnd', TMessageType.CALL, self._seqid)
    args = auditRecordStartEnd_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartEnd failed: unknown result")

  def auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to {@code record} between {@code start}
    (inclusive) and {@code end} (non-inclusive).

    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
    return self.recv_auditRecordStartstrEndstr()

  def send_auditRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = auditRecordStartstrEndstr_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditRecordStartstrEndstr failed: unknown result")

  def auditKeyRecord(self, key, record, creds, transaction, environment):
    """
    List all the changes ever made to the {@code key} field in {@code record}.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecord(key, record, creds, transaction, environment)
    return self.recv_auditKeyRecord()

  def send_auditKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecord', TMessageType.CALL, self._seqid)
    args = auditKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecord failed: unknown result")

  def auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_auditKeyRecordStart()

  def send_auditKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStart', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStart failed: unknown result")

  def auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record} since
    {@code start} (inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_auditKeyRecordStartstr()

  def send_auditKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstr failed: unknown result")

  def auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent change that
                 should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_auditKeyRecordStartEnd()

  def send_auditKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartEnd failed: unknown result")

  def auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List all the changes made to the {@code key} field in {@code record}
    between {@code start} (inclusive) and {@code end} (non-inclusive).

    @param key the field name
    @param record the record id
    @param start an inclusive timestamp for the oldest change that should
                   possibly be included in the audit
    @param end a non-inclusive timestamp that for the most recent recent
                 change that should possibly be included in the audit
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return for each change, a mapping from timestamp to a description of the
            revision
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_auditKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_auditKeyRecordStartstrEndstr()

  def send_auditKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('auditKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = auditKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_auditKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = auditKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "auditKeyRecordStartstrEndstr failed: unknown result")

  def browseKey(self, key, creds, transaction, environment):
    """
    View the values from all records that are currently stored for {@code key}.

    @param keys the field name
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contain that value in the {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - creds
     - transaction
     - environment
    """
    self.send_browseKey(key, creds, transaction, environment)
    return self.recv_browseKey()

  def send_browseKey(self, key, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKey', TMessageType.CALL, self._seqid)
    args = browseKey_args()
    args.key = key
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKey(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKey_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKey failed: unknown result")

  def browseKeys(self, keys, creds, transaction, environment):
    """
    View the values from all records that are currently stored for each of the
    {@code keys}.

    @param keys a list of field names
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the set of records that contain that value in the
            {@code key} field
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - creds
     - transaction
     - environment
    """
    self.send_browseKeys(keys, creds, transaction, environment)
    return self.recv_browseKeys()

  def send_browseKeys(self, keys, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeys', TMessageType.CALL, self._seqid)
    args = browseKeys_args()
    args.keys = keys
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeys(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeys_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeys failed: unknown result")

  def browseKeyTime(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeyTime(key, timestamp, creds, transaction, environment)
    return self.recv_browseKeyTime()

  def send_browseKeyTime(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeyTime', TMessageType.CALL, self._seqid)
    args = browseKeyTime_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeyTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeyTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTime failed: unknown result")

  def browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for {@code key} at
    {@code timestamp}.

    @param keys the field name
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each value to the {@link Set} of records
            that contained that value in the {@code key} field at {@code
            timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeyTimestr(key, timestamp, creds, transaction, environment)
    return self.recv_browseKeyTimestr()

  def send_browseKeyTimestr(self, key, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeyTimestr', TMessageType.CALL, self._seqid)
    args = browseKeyTimestr_args()
    args.key = key
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeyTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeyTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeyTimestr failed: unknown result")

  def browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeysTime(keys, timestamp, creds, transaction, environment)
    return self.recv_browseKeysTime()

  def send_browseKeysTime(self, keys, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeysTime', TMessageType.CALL, self._seqid)
    args = browseKeysTime_args()
    args.keys = keys
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeysTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeysTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTime failed: unknown result")

  def browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    """
    View the values from all records that were stored for each of the
    {@code keys} at {@code timestamp}.

    @param keys a list of field names
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each key to a {@link Map} associating
            each value to the {@link Set} of records that contained that value
            in the {@code key} field at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - keys
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_browseKeysTimestr(keys, timestamp, creds, transaction, environment)
    return self.recv_browseKeysTimestr()

  def send_browseKeysTimestr(self, keys, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('browseKeysTimestr', TMessageType.CALL, self._seqid)
    args = browseKeysTimestr_args()
    args.keys = keys
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_browseKeysTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = browseKeysTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "browseKeysTimestr failed: unknown result")

  def chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    """
    View a time series that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecord(key, record, creds, transaction, environment)
    return self.recv_chronologizeKeyRecord()

  def send_chronologizeKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecord', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecord failed: unknown result")

  def chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStart()

  def send_chronologizeKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStart', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStart failed: unknown result")

  def chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and the present that
    associates the timestamp of each modification for {@code key} in
    {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartstr()

  def send_chronologizeKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstr failed: unknown result")

  def chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartEnd()

  def send_chronologizeKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartEnd failed: unknown result")

  def chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    View a time series between {@code start} (inclusive) and {@code end}
    (non-inclusive) that associates the timestamp of each modification for
    {@code key} in {@code record} to a snapshot containing the values that
    were stored in the field after the change.

    @param key the field name
    @param record the record id
    @param start the first possible {@link Timestamp} to include in the
               time series
    @param end the {@link Timestamp} that should be greater than every
               timestamp in the time series
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each modification timestamp to the
            {@link Set} of values that were stored in the field after the
            change.
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_chronologizeKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_chronologizeKeyRecordStartstrEndstr()

  def send_chronologizeKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('chronologizeKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = chronologizeKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_chronologizeKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = chronologizeKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "chronologizeKeyRecordStartstrEndstr failed: unknown result")

  def clearRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearRecord(record, creds, transaction, environment)
    self.recv_clearRecord()

  def send_clearRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearRecord', TMessageType.CALL, self._seqid)
    args = clearRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearRecords(records, creds, transaction, environment)
    self.recv_clearRecords()

  def send_clearRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearRecords', TMessageType.CALL, self._seqid)
    args = clearRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearKeyRecord(key, record, creds, transaction, environment)
    self.recv_clearKeyRecord()

  def send_clearKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeyRecord', TMessageType.CALL, self._seqid)
    args = clearKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_clearKeysRecord(keys, record, creds, transaction, environment)
    self.recv_clearKeysRecord()

  def send_clearKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeysRecord', TMessageType.CALL, self._seqid)
    args = clearKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearKeyRecords(key, records, creds, transaction, environment)
    self.recv_clearKeyRecords()

  def send_clearKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeyRecords', TMessageType.CALL, self._seqid)
    args = clearKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def clearKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_clearKeysRecords(keys, records, creds, transaction, environment)
    self.recv_clearKeysRecords()

  def send_clearKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('clearKeysRecords', TMessageType.CALL, self._seqid)
    args = clearKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = clearKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def commit(self, creds, transaction, environment):
    """
    Attempt to permanently commit any changes that are staged in a transaction
    and return {@code true} if and only if all the changes can be applied.
    Otherwise, returns {@code false} and all the changes are discarded.
    <p>
    After returning, the driver will return to {@code autocommit} mode and
    all subsequent changes will be committed immediately.
    </p>
    <p>
    This method will return {@code false} if it is called when the driver is
    not in {@code staging} mode.
    </p>

    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return {@code true} if all staged changes are committed, otherwise {@code
                         false}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_commit(creds, transaction, environment)
    return self.recv_commit()

  def send_commit(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('commit', TMessageType.CALL, self._seqid)
    args = commit_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = commit_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commit failed: unknown result")

  def describeRecord(self, record, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys in {@code record}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_describeRecord(record, creds, transaction, environment)
    return self.recv_describeRecord()

  def send_describeRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecord', TMessageType.CALL, self._seqid)
    args = describeRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecord failed: unknown result")

  def describeRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that had at least one value at
    {@code timestamp}.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordTime(record, timestamp, creds, transaction, environment)
    return self.recv_describeRecordTime()

  def send_describeRecordTime(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordTime', TMessageType.CALL, self._seqid)
    args = describeRecordTime_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTime failed: unknown result")

  def describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    List all the keys in {@code record} that have at least one value.

    @param record the record id
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the {@link Set} of keys that were in {@code record} at
            {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordTimestr(record, timestamp, creds, transaction, environment)
    return self.recv_describeRecordTimestr()

  def send_describeRecordTimestr(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordTimestr', TMessageType.CALL, self._seqid)
    args = describeRecordTimestr_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordTimestr failed: unknown result")

  def describeRecords(self, records, creds, transaction, environment):
    """
    For each of the {@code records}, list all of the keys that have at least
    one value.

    @param records a collection of record ids
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys in that record
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_describeRecords(records, creds, transaction, environment)
    return self.recv_describeRecords()

  def send_describeRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecords', TMessageType.CALL, self._seqid)
    args = describeRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecords failed: unknown result")

  def describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordsTime(records, timestamp, creds, transaction, environment)
    return self.recv_describeRecordsTime()

  def send_describeRecordsTime(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordsTime', TMessageType.CALL, self._seqid)
    args = describeRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTime failed: unknown result")

  def describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    For each of the {@code records}, list all the keys that had at least one
    value at {@code timestamp}.

    @param records a collection of record ids
    @param timestamp the historical timestamp to use in the lookup
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} associating each record id to the {@link Set} of
            keys that were in that record at {@code timestamp}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_describeRecordsTimestr(records, timestamp, creds, transaction, environment)
    return self.recv_describeRecordsTimestr()

  def send_describeRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('describeRecordsTimestr', TMessageType.CALL, self._seqid)
    args = describeRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = describeRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeRecordsTimestr failed: unknown result")

  def diffRecordStart(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStart(record, start, creds, transaction, environment)
    return self.recv_diffRecordStart()

  def send_diffRecordStart(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStart', TMessageType.CALL, self._seqid)
    args = diffRecordStart_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStart failed: unknown result")

  def diffRecordStartstr(self, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code record} since {@code start}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at the present.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartstr(record, start, creds, transaction, environment)
    return self.recv_diffRecordStartstr()

  def send_diffRecordStartstr(self, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartstr', TMessageType.CALL, self._seqid)
    args = diffRecordStartstr_args()
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstr failed: unknown result")

  def diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartEnd(record, start, tend, creds, transaction, environment)
    return self.recv_diffRecordStartEnd()

  def send_diffRecordStartEnd(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartEnd', TMessageType.CALL, self._seqid)
    args = diffRecordStartEnd_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartEnd failed: unknown result")

  def diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code record} from {@code start} to
    {@code end}.

    <p>
    If you begin with the state of the {@code record} at {@code start} and
    re-apply all the changes in the diff, you'll re-create the state of the
    {@code record} at {@code end}.
    </p>

    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each key in the {@code record} to
            another {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {"key": {ADDED: ["value1", "value2"], REMOVED: ["value3",
            "value4"]}}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffRecordStartstrEndstr(record, start, tend, creds, transaction, environment)
    return self.recv_diffRecordStartstrEndstr()

  def send_diffRecordStartstrEndstr(self, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffRecordStartstrEndstr_args()
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffRecordStartstrEndstr failed: unknown result")

  def diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStart(key, record, start, creds, transaction, environment)
    return self.recv_diffKeyRecordStart()

  def send_diffKeyRecordStart(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStart', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStart_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStart failed: unknown result")

  def diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} since
    {@code start}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    the present.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartstr(key, record, start, creds, transaction, environment)
    return self.recv_diffKeyRecordStartstr()

  def send_diffKeyRecordStartstr(self, key, record, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartstr', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstr failed: unknown result")

  def diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartEnd(key, record, start, tend, creds, transaction, environment)
    return self.recv_diffKeyRecordStartEnd()

  def send_diffKeyRecordStartEnd(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartEnd', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartEnd_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartEnd failed: unknown result")

  def diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    """
    List the net changes made to {@code key} in {@code record} from
    {@code start} to {@code end}.

    <p>
    If you begin with the state of the field at {@code start} and re-apply
    all the changes in the diff, you'll re-create the state of the field at
    {@code end}.
    </p>

    @param key the field name
    @param record the record id
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates a {@link Diff change
            description} to the {@link Set} of values that fit the
            description (i.e. <code>
            {ADDED: ["value1", "value2"], REMOVED: ["value3", "value4"]}
            </code> )
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - record
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyRecordStartstrEndstr(key, record, start, tend, creds, transaction, environment)
    return self.recv_diffKeyRecordStartstrEndstr()

  def send_diffKeyRecordStartstrEndstr(self, key, record, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyRecordStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffKeyRecordStartstrEndstr_args()
    args.key = key
    args.record = record
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyRecordStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyRecordStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyRecordStartstrEndstr failed: unknown result")

  def diffKeyStart(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStart(key, start, creds, transaction, environment)
    return self.recv_diffKeyStart()

  def send_diffKeyStart(self, key, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStart', TMessageType.CALL, self._seqid)
    args = diffKeyStart_args()
    args.key = key
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStart(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStart_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStart failed: unknown result")

  def diffKeyStartstr(self, key, start, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    since {@code start}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at the present.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartstr(key, start, creds, transaction, environment)
    return self.recv_diffKeyStartstr()

  def send_diffKeyStartstr(self, key, start, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartstr', TMessageType.CALL, self._seqid)
    args = diffKeyStartstr_args()
    args.key = key
    args.start = start
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstr failed: unknown result")

  def diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartEnd(key, start, tend, creds, transaction, environment)
    return self.recv_diffKeyStartEnd()

  def send_diffKeyStartEnd(self, key, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartEnd', TMessageType.CALL, self._seqid)
    args = diffKeyStartEnd_args()
    args.key = key
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartEnd(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartEnd_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartEnd failed: unknown result")

  def diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    """
    List the net changes made to the {@code key} field across all records
    from {@code start} to {@code end}.

    <p>
    If you begin with the state of an inverted index for {@code key} at
    {@code start} and re-apply all the changes in the diff, you'll re-create
    the state of the same index at {@code end}.
    </p>

    @param key the field name
    @param start the base timestamp from which the diff is calculated
    @param end the comparison timestamp to which the diff is calculated
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a {@link Map} that associates each value stored for {@code key}
            across all records to another {@link Map} that associates a
            {@link Diff change description} to the {@link Set} of records
            where the description applies to that value in the {@code key}
            field (i.e. <code>
            {"value1": {ADDED: [1, 2], REMOVED: [3, 4]}}
            </code>)
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.ParseException if a string cannot be properly parsed
            into a timestamp

    Parameters:
     - key
     - start
     - tend
     - creds
     - transaction
     - environment
    """
    self.send_diffKeyStartstrEndstr(key, start, tend, creds, transaction, environment)
    return self.recv_diffKeyStartstrEndstr()

  def send_diffKeyStartstrEndstr(self, key, start, tend, creds, transaction, environment):
    self._oprot.writeMessageBegin('diffKeyStartstrEndstr', TMessageType.CALL, self._seqid)
    args = diffKeyStartstrEndstr_args()
    args.key = key
    args.start = start
    args.tend = tend
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diffKeyStartstrEndstr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = diffKeyStartstrEndstr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diffKeyStartstrEndstr failed: unknown result")

  def invokePlugin(self, id, method, params, creds, transaction, environment):
    """
    Invoke a Plugin method.

    <p>
    Assuming that there is a plugin distribution that contains a class
    named after {@code id}, and has the specified {@code method}, invoke the
    same with {@code params} and return the result.
    </p>

    @param id the fully qualified name of the plugin class
    @param method the name of the method in {@code clazz} to invoke
    @param params a list of TObjects to pass to {@code method} as args
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return the result of the method invocation
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of the arguments are
            invalid

    Parameters:
     - id
     - method
     - params
     - creds
     - transaction
     - environment
    """
    self.send_invokePlugin(id, method, params, creds, transaction, environment)
    return self.recv_invokePlugin()

  def send_invokePlugin(self, id, method, params, creds, transaction, environment):
    self._oprot.writeMessageBegin('invokePlugin', TMessageType.CALL, self._seqid)
    args = invokePlugin_args()
    args.id = id
    args.method = method
    args.params = params
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_invokePlugin(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = invokePlugin_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "invokePlugin failed: unknown result")

  def login(self, username, password, environment):
    """
    Attempt to authenticate the user identified by the {@code username} and
    {@code password} combination to the specified {@code environment}. If
    successful, establish a new session within the {@code environment} on
    behalf of that user and return an {@link shared.AccessToken}, which is
    required for all subsequent operations.

    <p>
    The AccessToken <em>may</em> expire after a while so clients should be
    prepared to seamlessly login again for active user sessions.
    </p>

    @param username a binary representation of the UTF-8 encoded username
    @param password a binary representation of the UTF-8 encoded password
    @param environment the name of the environment into which to login
    @return an {@link shared.AccessToken} to submit with all subsequent method
            calls
    @throws exceptions.SecurityException if the login is not successful

    Parameters:
     - username
     - password
     - environment
    """
    self.send_login(username, password, environment)
    return self.recv_login()

  def send_login(self, username, password, environment):
    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
    args = login_args()
    args.username = username
    args.password = password
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_login(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = login_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result")

  def logout(self, token, environment):
    """
    Terminate the session within {@code environment} for the user represented
    by the {@code token}. Afterwards, all other attempts to use {@code token}
    will result in a {@link exceptions.SecurityException} being thrown.

    @param token the {@link shared.AccessToken to expire}
    @param environment the environment of the session represented by the
                       {@code token}
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session

    Parameters:
     - token
     - environment
    """
    self.send_logout(token, environment)
    self.recv_logout()

  def send_logout(self, token, environment):
    self._oprot.writeMessageBegin('logout', TMessageType.CALL, self._seqid)
    args = logout_args()
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_logout(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = logout_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    return

  def stage(self, token, environment):
    """
    Start a new transaction.
    <p>
    This method will turn on STAGING mode so that all subsequent changes are
    collected in an isolated buffer before possibly being committed to the
    database. Staged operations are guaranteed to be reliable, all or nothing
    units of work that allow correct recovery from failures and provide
    isolation between clients so the database is always in a consistent state.
    </p>
    <p>
    After this method returns, all subsequent operations will be done in
    {@code staging} mode until either #abort(shared.AccessToken) or
    #commit(shared.AccessToken) is called.
    </p>

    @param token
    @param environment
    @return TransactionToken
    @throws TSecurityException

    Parameters:
     - token
     - environment
    """
    self.send_stage(token, environment)
    return self.recv_stage()

  def send_stage(self, token, environment):
    self._oprot.writeMessageBegin('stage', TMessageType.CALL, self._seqid)
    args = stage_args()
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stage(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = stage_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stage failed: unknown result")

  def insertJson(self, json, creds, transaction, environment):
    """
    Parameters:
     - json
     - creds
     - transaction
     - environment
    """
    self.send_insertJson(json, creds, transaction, environment)
    return self.recv_insertJson()

  def send_insertJson(self, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJson', TMessageType.CALL, self._seqid)
    args = insertJson_args()
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJson failed: unknown result")

  def insertJsonRecord(self, json, record, creds, transaction, environment):
    """
    Parameters:
     - json
     - record
     - creds
     - transaction
     - environment
    """
    self.send_insertJsonRecord(json, record, creds, transaction, environment)
    return self.recv_insertJsonRecord()

  def send_insertJsonRecord(self, json, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJsonRecord', TMessageType.CALL, self._seqid)
    args = insertJsonRecord_args()
    args.json = json
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJsonRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJsonRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecord failed: unknown result")

  def insertJsonRecords(self, json, records, creds, transaction, environment):
    """
    Parameters:
     - json
     - records
     - creds
     - transaction
     - environment
    """
    self.send_insertJsonRecords(json, records, creds, transaction, environment)
    return self.recv_insertJsonRecords()

  def send_insertJsonRecords(self, json, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('insertJsonRecords', TMessageType.CALL, self._seqid)
    args = insertJsonRecords_args()
    args.json = json
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insertJsonRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = insertJsonRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insertJsonRecords failed: unknown result")

  def removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_removeKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_removeKeyValueRecord()

  def send_removeKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('removeKeyValueRecord', TMessageType.CALL, self._seqid)
    args = removeKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecord failed: unknown result")

  def removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_removeKeyValueRecords(key, value, records, creds, transaction, environment)
    return self.recv_removeKeyValueRecords()

  def send_removeKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('removeKeyValueRecords', TMessageType.CALL, self._seqid)
    args = removeKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = removeKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeKeyValueRecords failed: unknown result")

  def setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValueRecord(key, value, record, creds, transaction, environment)
    self.recv_setKeyValueRecord()

  def send_setKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValueRecord', TMessageType.CALL, self._seqid)
    args = setKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def setKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValue(key, value, creds, transaction, environment)
    return self.recv_setKeyValue()

  def send_setKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValue', TMessageType.CALL, self._seqid)
    args = setKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setKeyValue failed: unknown result")

  def setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - records
     - creds
     - transaction
     - environment
    """
    self.send_setKeyValueRecords(key, value, records, creds, transaction, environment)
    self.recv_setKeyValueRecords()

  def send_setKeyValueRecords(self, key, value, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('setKeyValueRecords', TMessageType.CALL, self._seqid)
    args = setKeyValueRecords_args()
    args.key = key
    args.value = value
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setKeyValueRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = setKeyValueRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    """
    The {@code value} in {@code key} of {@code record} are added
    and removed to be set as exactly the same as the input values

    @param key the field name
    @param record the record id where an attempt is made to add the data
    @param values collection of values to set
    @param creds the {@link shared.AccessToken} that is used to authenticate
                   the user on behalf of whom the client is connected
    @param transaction the {@link shared.TransactionToken} that the
                         server uses to find the current transaction for the
                         client (optional)
    @param environment the environment to which the client is connected
    @return a bool that indicates if the data was added
    @throws exceptions.SecurityException if the {@code creds} don't
            represent a valid session
    @throws exceptions.TransactionException if the client was in a
            transaction and an error occurred that caused the transaction
            to end itself
    @throws exceptions.InvalidArgumentException if any of provided data
            can't be stored

    Parameters:
     - key
     - record
     - values
     - creds
     - transaction
     - environment
    """
    self.send_reconcileKeyRecordValues(key, record, values, creds, transaction, environment)
    self.recv_reconcileKeyRecordValues()

  def send_reconcileKeyRecordValues(self, key, record, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('reconcileKeyRecordValues', TMessageType.CALL, self._seqid)
    args = reconcileKeyRecordValues_args()
    args.key = key
    args.record = record
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_reconcileKeyRecordValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = reconcileKeyRecordValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def inventory(self, creds, transaction, environment):
    """
    Parameters:
     - creds
     - transaction
     - environment
    """
    self.send_inventory(creds, transaction, environment)
    return self.recv_inventory()

  def send_inventory(self, creds, transaction, environment):
    self._oprot.writeMessageBegin('inventory', TMessageType.CALL, self._seqid)
    args = inventory_args()
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_inventory(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = inventory_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "inventory failed: unknown result")

  def selectRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectRecord(record, creds, transaction, environment)
    return self.recv_selectRecord()

  def send_selectRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecord', TMessageType.CALL, self._seqid)
    args = selectRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecord failed: unknown result")

  def selectRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectRecords(records, creds, transaction, environment)
    return self.recv_selectRecords()

  def send_selectRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecords', TMessageType.CALL, self._seqid)
    args = selectRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecords failed: unknown result")

  def selectRecordTime(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordTime(record, timestamp, creds, transaction, environment)
    return self.recv_selectRecordTime()

  def send_selectRecordTime(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordTime', TMessageType.CALL, self._seqid)
    args = selectRecordTime_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTime failed: unknown result")

  def selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordTimestr(record, timestamp, creds, transaction, environment)
    return self.recv_selectRecordTimestr()

  def send_selectRecordTimestr(self, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectRecordTimestr_args()
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordTimestr failed: unknown result")

  def selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordsTime(records, timestamp, creds, transaction, environment)
    return self.recv_selectRecordsTime()

  def send_selectRecordsTime(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordsTime', TMessageType.CALL, self._seqid)
    args = selectRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTime failed: unknown result")

  def selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectRecordsTimestr(records, timestamp, creds, transaction, environment)
    return self.recv_selectRecordsTimestr()

  def send_selectRecordsTimestr(self, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectRecordsTimestr failed: unknown result")

  def selectKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecord(key, record, creds, transaction, environment)
    return self.recv_selectKeyRecord()

  def send_selectKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecord', TMessageType.CALL, self._seqid)
    args = selectKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecord failed: unknown result")

  def selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordTime()

  def send_selectKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordTime', TMessageType.CALL, self._seqid)
    args = selectKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTime failed: unknown result")

  def selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordTimestr()

  def send_selectKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordTimestr failed: unknown result")

  def selectKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_selectKeysRecord()

  def send_selectKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecord', TMessageType.CALL, self._seqid)
    args = selectKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecord failed: unknown result")

  def selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordTime()

  def send_selectKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordTime', TMessageType.CALL, self._seqid)
    args = selectKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTime failed: unknown result")

  def selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordTimestr()

  def send_selectKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordTimestr failed: unknown result")

  def selectKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_selectKeysRecords()

  def send_selectKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecords', TMessageType.CALL, self._seqid)
    args = selectKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecords failed: unknown result")

  def selectKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecords(key, records, creds, transaction, environment)
    return self.recv_selectKeyRecords()

  def send_selectKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecords', TMessageType.CALL, self._seqid)
    args = selectKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecords failed: unknown result")

  def selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordsTime()

  def send_selectKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = selectKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTime failed: unknown result")

  def selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeyRecordsTimestr()

  def send_selectKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyRecordsTimestr failed: unknown result")

  def selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordsTime()

  def send_selectKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = selectKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTime failed: unknown result")

  def selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_selectKeysRecordsTimestr()

  def send_selectKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysRecordsTimestr failed: unknown result")

  def selectCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteria(criteria, creds, transaction, environment)
    return self.recv_selectCriteria()

  def send_selectCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteria', TMessageType.CALL, self._seqid)
    args = selectCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteria failed: unknown result")

  def selectCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectCcl(ccl, creds, transaction, environment)
    return self.recv_selectCcl()

  def send_selectCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCcl', TMessageType.CALL, self._seqid)
    args = selectCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCcl failed: unknown result")

  def selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteriaTime(criteria, timestamp, creds, transaction, environment)
    return self.recv_selectCriteriaTime()

  def send_selectCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectCriteriaTime_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTime failed: unknown result")

  def selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
    return self.recv_selectCriteriaTimestr()

  def send_selectCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectCriteriaTimestr_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCriteriaTimestr failed: unknown result")

  def selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCclTime(ccl, timestamp, creds, transaction, environment)
    return self.recv_selectCclTime()

  def send_selectCclTime(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCclTime', TMessageType.CALL, self._seqid)
    args = selectCclTime_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTime failed: unknown result")

  def selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectCclTimestr(ccl, timestamp, creds, transaction, environment)
    return self.recv_selectCclTimestr()

  def send_selectCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectCclTimestr', TMessageType.CALL, self._seqid)
    args = selectCclTimestr_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectCclTimestr failed: unknown result")

  def selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_selectKeyCriteria()

  def send_selectKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteria', TMessageType.CALL, self._seqid)
    args = selectKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteria failed: unknown result")

  def selectKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_selectKeyCcl()

  def send_selectKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCcl', TMessageType.CALL, self._seqid)
    args = selectKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCcl failed: unknown result")

  def selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCriteriaTime()

  def send_selectKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTime failed: unknown result")

  def selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCriteriaTimestr()

  def send_selectKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCriteriaTimestr failed: unknown result")

  def selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCclTime()

  def send_selectKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCclTime', TMessageType.CALL, self._seqid)
    args = selectKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTime failed: unknown result")

  def selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeyCclTimestr()

  def send_selectKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = selectKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeyCclTimestr failed: unknown result")

  def selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_selectKeysCriteria()

  def send_selectKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteria', TMessageType.CALL, self._seqid)
    args = selectKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteria failed: unknown result")

  def selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_selectKeysCcl()

  def send_selectKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCcl', TMessageType.CALL, self._seqid)
    args = selectKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCcl failed: unknown result")

  def selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCriteriaTime()

  def send_selectKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = selectKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTime failed: unknown result")

  def selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCriteriaTimestr()

  def send_selectKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCriteriaTimestr failed: unknown result")

  def selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCclTime()

  def send_selectKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCclTime', TMessageType.CALL, self._seqid)
    args = selectKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTime failed: unknown result")

  def selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_selectKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_selectKeysCclTimestr()

  def send_selectKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('selectKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = selectKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_selectKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = selectKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "selectKeysCclTimestr failed: unknown result")

  def getKeyRecord(self, key, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecord(key, record, creds, transaction, environment)
    return self.recv_getKeyRecord()

  def send_getKeyRecord(self, key, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecord', TMessageType.CALL, self._seqid)
    args = getKeyRecord_args()
    args.key = key
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecord failed: unknown result")

  def getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordTime()

  def send_getKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordTime', TMessageType.CALL, self._seqid)
    args = getKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTime failed: unknown result")

  def getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordTimestr()

  def send_getKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = getKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordTimestr failed: unknown result")

  def getKeysRecord(self, keys, record, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecord(keys, record, creds, transaction, environment)
    return self.recv_getKeysRecord()

  def send_getKeysRecord(self, keys, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecord', TMessageType.CALL, self._seqid)
    args = getKeysRecord_args()
    args.keys = keys
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecord failed: unknown result")

  def getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordTime()

  def send_getKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordTime', TMessageType.CALL, self._seqid)
    args = getKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTime failed: unknown result")

  def getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordTimestr()

  def send_getKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = getKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordTimestr failed: unknown result")

  def getKeysRecords(self, keys, records, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecords(keys, records, creds, transaction, environment)
    return self.recv_getKeysRecords()

  def send_getKeysRecords(self, keys, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecords', TMessageType.CALL, self._seqid)
    args = getKeysRecords_args()
    args.keys = keys
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecords failed: unknown result")

  def getKeyRecords(self, key, records, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecords(key, records, creds, transaction, environment)
    return self.recv_getKeyRecords()

  def send_getKeyRecords(self, key, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecords', TMessageType.CALL, self._seqid)
    args = getKeyRecords_args()
    args.key = key
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecords failed: unknown result")

  def getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordsTime()

  def send_getKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = getKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTime failed: unknown result")

  def getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    return self.recv_getKeyRecordsTimestr()

  def send_getKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = getKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyRecordsTimestr failed: unknown result")

  def getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordsTime()

  def send_getKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = getKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTime failed: unknown result")

  def getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    return self.recv_getKeysRecordsTimestr()

  def send_getKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = getKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysRecordsTimestr failed: unknown result")

  def getKeyCriteria(self, key, criteria, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteria(key, criteria, creds, transaction, environment)
    return self.recv_getKeyCriteria()

  def send_getKeyCriteria(self, key, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteria', TMessageType.CALL, self._seqid)
    args = getKeyCriteria_args()
    args.key = key
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteria failed: unknown result")

  def getCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getCriteria(criteria, creds, transaction, environment)
    return self.recv_getCriteria()

  def send_getCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteria', TMessageType.CALL, self._seqid)
    args = getCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteria failed: unknown result")

  def getCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getCcl(ccl, creds, transaction, environment)
    return self.recv_getCcl()

  def send_getCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCcl', TMessageType.CALL, self._seqid)
    args = getCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCcl failed: unknown result")

  def getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCriteriaTime(criteria, timestamp, creds, transaction, environment)
    return self.recv_getCriteriaTime()

  def send_getCriteriaTime(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteriaTime', TMessageType.CALL, self._seqid)
    args = getCriteriaTime_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTime failed: unknown result")

  def getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCriteriaTimestr(criteria, timestamp, creds, transaction, environment)
    return self.recv_getCriteriaTimestr()

  def send_getCriteriaTimestr(self, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getCriteriaTimestr_args()
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCriteriaTimestr failed: unknown result")

  def getCclTime(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCclTime(ccl, timestamp, creds, transaction, environment)
    return self.recv_getCclTime()

  def send_getCclTime(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCclTime', TMessageType.CALL, self._seqid)
    args = getCclTime_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTime failed: unknown result")

  def getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getCclTimestr(ccl, timestamp, creds, transaction, environment)
    return self.recv_getCclTimestr()

  def send_getCclTimestr(self, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getCclTimestr', TMessageType.CALL, self._seqid)
    args = getCclTimestr_args()
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCclTimestr failed: unknown result")

  def getKeyCcl(self, key, ccl, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCcl(key, ccl, creds, transaction, environment)
    return self.recv_getKeyCcl()

  def send_getKeyCcl(self, key, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCcl', TMessageType.CALL, self._seqid)
    args = getKeyCcl_args()
    args.key = key
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCcl failed: unknown result")

  def getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteriaTime(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeyCriteriaTime()

  def send_getKeyCriteriaTime(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteriaTime', TMessageType.CALL, self._seqid)
    args = getKeyCriteriaTime_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTime failed: unknown result")

  def getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCriteriaTimestr(key, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeyCriteriaTimestr()

  def send_getKeyCriteriaTimestr(self, key, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getKeyCriteriaTimestr_args()
    args.key = key
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCriteriaTimestr failed: unknown result")

  def getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCclTime(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeyCclTime()

  def send_getKeyCclTime(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCclTime', TMessageType.CALL, self._seqid)
    args = getKeyCclTime_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTime failed: unknown result")

  def getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeyCclTimestr(key, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeyCclTimestr()

  def send_getKeyCclTimestr(self, key, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeyCclTimestr', TMessageType.CALL, self._seqid)
    args = getKeyCclTimestr_args()
    args.key = key
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeyCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeyCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeyCclTimestr failed: unknown result")

  def getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteria(keys, criteria, creds, transaction, environment)
    return self.recv_getKeysCriteria()

  def send_getKeysCriteria(self, keys, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteria', TMessageType.CALL, self._seqid)
    args = getKeysCriteria_args()
    args.keys = keys
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteria failed: unknown result")

  def getKeysCcl(self, keys, ccl, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCcl(keys, ccl, creds, transaction, environment)
    return self.recv_getKeysCcl()

  def send_getKeysCcl(self, keys, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCcl', TMessageType.CALL, self._seqid)
    args = getKeysCcl_args()
    args.keys = keys
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCcl failed: unknown result")

  def getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteriaTime(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeysCriteriaTime()

  def send_getKeysCriteriaTime(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteriaTime', TMessageType.CALL, self._seqid)
    args = getKeysCriteriaTime_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteriaTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteriaTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTime failed: unknown result")

  def getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - criteria
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCriteriaTimestr(keys, criteria, timestamp, creds, transaction, environment)
    return self.recv_getKeysCriteriaTimestr()

  def send_getKeysCriteriaTimestr(self, keys, criteria, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCriteriaTimestr', TMessageType.CALL, self._seqid)
    args = getKeysCriteriaTimestr_args()
    args.keys = keys
    args.criteria = criteria
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCriteriaTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCriteriaTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCriteriaTimestr failed: unknown result")

  def getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCclTime(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeysCclTime()

  def send_getKeysCclTime(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCclTime', TMessageType.CALL, self._seqid)
    args = getKeysCclTime_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCclTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCclTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTime failed: unknown result")

  def getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - ccl
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_getKeysCclTimestr(keys, ccl, timestamp, creds, transaction, environment)
    return self.recv_getKeysCclTimestr()

  def send_getKeysCclTimestr(self, keys, ccl, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('getKeysCclTimestr', TMessageType.CALL, self._seqid)
    args = getKeysCclTimestr_args()
    args.keys = keys
    args.ccl = ccl
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKeysCclTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getKeysCclTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKeysCclTimestr failed: unknown result")

  def verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecord(key, value, record, creds, transaction, environment)
    return self.recv_verifyKeyValueRecord()

  def send_verifyKeyValueRecord(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecord', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecord_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecord failed: unknown result")

  def verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecordTime(key, value, record, timestamp, creds, transaction, environment)
    return self.recv_verifyKeyValueRecordTime()

  def send_verifyKeyValueRecordTime(self, key, value, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecordTime', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecordTime_args()
    args.key = key
    args.value = value
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTime failed: unknown result")

  def verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_verifyKeyValueRecordTimestr(key, value, record, timestamp, creds, transaction, environment)
    return self.recv_verifyKeyValueRecordTimestr()

  def send_verifyKeyValueRecordTimestr(self, key, value, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyKeyValueRecordTimestr', TMessageType.CALL, self._seqid)
    args = verifyKeyValueRecordTimestr_args()
    args.key = key
    args.value = value
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyKeyValueRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyKeyValueRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyKeyValueRecordTimestr failed: unknown result")

  def jsonifyRecords(self, records, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecords(records, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecords()

  def send_jsonifyRecords(self, records, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecords', TMessageType.CALL, self._seqid)
    args = jsonifyRecords_args()
    args.records = records
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecords failed: unknown result")

  def jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecordsTime(records, timestamp, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecordsTime()

  def send_jsonifyRecordsTime(self, records, timestamp, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecordsTime', TMessageType.CALL, self._seqid)
    args = jsonifyRecordsTime_args()
    args.records = records
    args.timestamp = timestamp
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTime failed: unknown result")

  def jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    """
    Parameters:
     - records
     - timestamp
     - identifier
     - creds
     - transaction
     - environment
    """
    self.send_jsonifyRecordsTimestr(records, timestamp, identifier, creds, transaction, environment)
    return self.recv_jsonifyRecordsTimestr()

  def send_jsonifyRecordsTimestr(self, records, timestamp, identifier, creds, transaction, environment):
    self._oprot.writeMessageBegin('jsonifyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = jsonifyRecordsTimestr_args()
    args.records = records
    args.timestamp = timestamp
    args.identifier = identifier
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_jsonifyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = jsonifyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "jsonifyRecordsTimestr failed: unknown result")

  def findCriteria(self, criteria, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - creds
     - transaction
     - environment
    """
    self.send_findCriteria(criteria, creds, transaction, environment)
    return self.recv_findCriteria()

  def send_findCriteria(self, criteria, creds, transaction, environment):
    self._oprot.writeMessageBegin('findCriteria', TMessageType.CALL, self._seqid)
    args = findCriteria_args()
    args.criteria = criteria
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findCriteria(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findCriteria_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findCriteria failed: unknown result")

  def findCcl(self, ccl, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - creds
     - transaction
     - environment
    """
    self.send_findCcl(ccl, creds, transaction, environment)
    return self.recv_findCcl()

  def send_findCcl(self, ccl, creds, transaction, environment):
    self._oprot.writeMessageBegin('findCcl', TMessageType.CALL, self._seqid)
    args = findCcl_args()
    args.ccl = ccl
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findCcl(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findCcl_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findCcl failed: unknown result")

  def findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValues(key, operator, values, creds, transaction, environment)
    return self.recv_findKeyOperatorValues()

  def send_findKeyOperatorValues(self, key, operator, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValues', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValues_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValues failed: unknown result")

  def findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValuesTime(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorValuesTime()

  def send_findKeyOperatorValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValuesTime', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValuesTime_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValuesTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValuesTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTime failed: unknown result")

  def findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorValuesTimestr()

  def send_findKeyOperatorValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorValuesTimestr', TMessageType.CALL, self._seqid)
    args = findKeyOperatorValuesTimestr_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorValuesTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorValuesTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorValuesTimestr failed: unknown result")

  def findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValues(key, operator, values, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValues()

  def send_findKeyOperatorstrValues(self, key, operator, values, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValues', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValues_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValues(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValues_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValues failed: unknown result")

  def findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValuesTime(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValuesTime()

  def send_findKeyOperatorstrValuesTime(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValuesTime', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValuesTime_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValuesTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValuesTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTime failed: unknown result")

  def findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - operator
     - values
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_findKeyOperatorstrValuesTimestr(key, operator, values, timestamp, creds, transaction, environment)
    return self.recv_findKeyOperatorstrValuesTimestr()

  def send_findKeyOperatorstrValuesTimestr(self, key, operator, values, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('findKeyOperatorstrValuesTimestr', TMessageType.CALL, self._seqid)
    args = findKeyOperatorstrValuesTimestr_args()
    args.key = key
    args.operator = operator
    args.values = values
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findKeyOperatorstrValuesTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findKeyOperatorstrValuesTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findKeyOperatorstrValuesTimestr failed: unknown result")

  def search(self, key, query, creds, transaction, environment):
    """
    Parameters:
     - key
     - query
     - creds
     - transaction
     - environment
    """
    self.send_search(key, query, creds, transaction, environment)
    return self.recv_search()

  def send_search(self, key, query, creds, transaction, environment):
    self._oprot.writeMessageBegin('search', TMessageType.CALL, self._seqid)
    args = search_args()
    args.key = key
    args.query = query
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = search_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search failed: unknown result")

  def revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordsTime(keys, records, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordsTime()

  def send_revertKeysRecordsTime(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordsTime', TMessageType.CALL, self._seqid)
    args = revertKeysRecordsTime_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordsTimestr(keys, records, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordsTimestr()

  def send_revertKeysRecordsTimestr(self, keys, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordsTimestr', TMessageType.CALL, self._seqid)
    args = revertKeysRecordsTimestr_args()
    args.keys = keys
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordTime(keys, record, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordTime()

  def send_revertKeysRecordTime(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordTime', TMessageType.CALL, self._seqid)
    args = revertKeysRecordTime_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - keys
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeysRecordTimestr(keys, record, timestamp, creds, transaction, environment)
    self.recv_revertKeysRecordTimestr()

  def send_revertKeysRecordTimestr(self, keys, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeysRecordTimestr', TMessageType.CALL, self._seqid)
    args = revertKeysRecordTimestr_args()
    args.keys = keys
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeysRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeysRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordsTime(key, records, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordsTime()

  def send_revertKeyRecordsTime(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordsTime', TMessageType.CALL, self._seqid)
    args = revertKeyRecordsTime_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordsTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordsTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - records
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordsTimestr(key, records, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordsTimestr()

  def send_revertKeyRecordsTimestr(self, key, records, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordsTimestr', TMessageType.CALL, self._seqid)
    args = revertKeyRecordsTimestr_args()
    args.key = key
    args.records = records
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordsTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordsTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordTime(key, record, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordTime()

  def send_revertKeyRecordTime(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordTime', TMessageType.CALL, self._seqid)
    args = revertKeyRecordTime_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordTime(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordTime_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    return

  def revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    """
    Parameters:
     - key
     - record
     - timestamp
     - creds
     - transaction
     - environment
    """
    self.send_revertKeyRecordTimestr(key, record, timestamp, creds, transaction, environment)
    self.recv_revertKeyRecordTimestr()

  def send_revertKeyRecordTimestr(self, key, record, timestamp, creds, transaction, environment):
    self._oprot.writeMessageBegin('revertKeyRecordTimestr', TMessageType.CALL, self._seqid)
    args = revertKeyRecordTimestr_args()
    args.key = key
    args.record = record
    args.timestamp = timestamp
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_revertKeyRecordTimestr(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = revertKeyRecordTimestr_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def pingRecords(self, records, creds, transaction, environment):
    """
    Parameters:
     - records
     - creds
     - transaction
     - environment
    """
    self.send_pingRecords(records, creds, transaction, environment)
    return self.recv_pingRecords()

  def send_pingRecords(self, records, creds, transaction, environment):
    self._oprot.writeMessageBegin('pingRecords', TMessageType.CALL, self._seqid)
    args = pingRecords_args()
    args.records = records
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingRecords(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pingRecords_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecords failed: unknown result")

  def pingRecord(self, record, creds, transaction, environment):
    """
    Parameters:
     - record
     - creds
     - transaction
     - environment
    """
    self.send_pingRecord(record, creds, transaction, environment)
    return self.recv_pingRecord()

  def send_pingRecord(self, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('pingRecord', TMessageType.CALL, self._seqid)
    args = pingRecord_args()
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_pingRecord(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = pingRecord_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "pingRecord failed: unknown result")

  def verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    """
    Parameters:
     - key
     - expected
     - record
     - replacement
     - creds
     - transaction
     - environment
    """
    self.send_verifyAndSwap(key, expected, record, replacement, creds, transaction, environment)
    return self.recv_verifyAndSwap()

  def send_verifyAndSwap(self, key, expected, record, replacement, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyAndSwap', TMessageType.CALL, self._seqid)
    args = verifyAndSwap_args()
    args.key = key
    args.expected = expected
    args.record = record
    args.replacement = replacement
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyAndSwap(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyAndSwap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyAndSwap failed: unknown result")

  def verifyOrSet(self, key, value, record, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - record
     - creds
     - transaction
     - environment
    """
    self.send_verifyOrSet(key, value, record, creds, transaction, environment)
    self.recv_verifyOrSet()

  def send_verifyOrSet(self, key, value, record, creds, transaction, environment):
    self._oprot.writeMessageBegin('verifyOrSet', TMessageType.CALL, self._seqid)
    args = verifyOrSet_args()
    args.key = key
    args.value = value
    args.record = record
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyOrSet(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = verifyOrSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    return

  def findOrAddKeyValue(self, key, value, creds, transaction, environment):
    """
    Parameters:
     - key
     - value
     - creds
     - transaction
     - environment
    """
    self.send_findOrAddKeyValue(key, value, creds, transaction, environment)
    return self.recv_findOrAddKeyValue()

  def send_findOrAddKeyValue(self, key, value, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrAddKeyValue', TMessageType.CALL, self._seqid)
    args = findOrAddKeyValue_args()
    args.key = key
    args.value = value
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrAddKeyValue(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrAddKeyValue_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    if result.ex4 is not None:
      raise result.ex4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrAddKeyValue failed: unknown result")

  def findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    """
    Parameters:
     - criteria
     - json
     - creds
     - transaction
     - environment
    """
    self.send_findOrInsertCriteriaJson(criteria, json, creds, transaction, environment)
    return self.recv_findOrInsertCriteriaJson()

  def send_findOrInsertCriteriaJson(self, criteria, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrInsertCriteriaJson', TMessageType.CALL, self._seqid)
    args = findOrInsertCriteriaJson_args()
    args.criteria = criteria
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrInsertCriteriaJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrInsertCriteriaJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCriteriaJson failed: unknown result")

  def findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    """
    Parameters:
     - ccl
     - json
     - creds
     - transaction
     - environment
    """
    self.send_findOrInsertCclJson(ccl, json, creds, transaction, environment)
    return self.recv_findOrInsertCclJson()

  def send_findOrInsertCclJson(self, ccl, json, creds, transaction, environment):
    self._oprot.writeMessageBegin('findOrInsertCclJson', TMessageType.CALL, self._seqid)
    args = findOrInsertCclJson_args()
    args.ccl = ccl
    args.json = json
    args.creds = creds
    args.transaction = transaction
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_findOrInsertCclJson(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = findOrInsertCclJson_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    if result.ex4 is not None:
      raise result.ex4
    raise TApplicationException(TApplicationException.MISSING_RESULT, "findOrInsertCclJson failed: unknown result")

  def getServerEnvironment(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    self.send_getServerEnvironment(creds, token, environment)
    return self.recv_getServerEnvironment()

  def send_getServerEnvironment(self, creds, token, environment):
    self._oprot.writeMessageBegin('getServerEnvironment', TMessageType.CALL, self._seqid)
    args = getServerEnvironment_args()
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerEnvironment(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getServerEnvironment_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerEnvironment failed: unknown result")

  def getServerVersion(self):
    self.send_getServerVersion()
    return self.recv_getServerVersion()

  def send_getServerVersion(self):
    self._oprot.writeMessageBegin('getServerVersion', TMessageType.CALL, self._seqid)
    args = getServerVersion_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerVersion(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = getServerVersion_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerVersion failed: unknown result")

  def time(self, creds, token, environment):
    """
    Parameters:
     - creds
     - token
     - environment
    """
    self.send_time(creds, token, environment)
    return self.recv_time()

  def send_time(self, creds, token, environment):
    self._oprot.writeMessageBegin('time', TMessageType.CALL, self._seqid)
    args = time_args()
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_time(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = time_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "time failed: unknown result")

  def timePhrase(self, phrase, creds, token, environment):
    """
    Parameters:
     - phrase
     - creds
     - token
     - environment
    """
    self.send_timePhrase(phrase, creds, token, environment)
    return self.recv_timePhrase()

  def send_timePhrase(self, phrase, creds, token, environment):
    self._oprot.writeMessageBegin('timePhrase', TMessageType.CALL, self._seqid)
    args = timePhrase_args()
    args.phrase = phrase
    args.creds = creds
    args.token = token
    args.environment = environment
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_timePhrase(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = timePhrase_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ex is not None:
      raise result.ex
    if result.ex2 is not None:
      raise result.ex2
    if result.ex3 is not None:
      raise result.ex3
    raise TApplicationException(TApplicationException.MISSING_RESULT, "timePhrase failed: unknown result")


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["abort"] = Processor.process_abort
    self._processMap["addKeyValue"] = Processor.process_addKeyValue
    self._processMap["addKeyValueRecord"] = Processor.process_addKeyValueRecord
    self._processMap["addKeyValueRecords"] = Processor.process_addKeyValueRecords
    self._processMap["auditRecord"] = Processor.process_auditRecord
    self._processMap["auditRecordStart"] = Processor.process_auditRecordStart
    self._processMap["auditRecordStartstr"] = Processor.process_auditRecordStartstr
    self._processMap["auditRecordStartEnd"] = Processor.process_auditRecordStartEnd
    self._processMap["auditRecordStartstrEndstr"] = Processor.process_auditRecordStartstrEndstr
    self._processMap["auditKeyRecord"] = Processor.process_auditKeyRecord
    self._processMap["auditKeyRecordStart"] = Processor.process_auditKeyRecordStart
    self._processMap["auditKeyRecordStartstr"] = Processor.process_auditKeyRecordStartstr
    self._processMap["auditKeyRecordStartEnd"] = Processor.process_auditKeyRecordStartEnd
    self._processMap["auditKeyRecordStartstrEndstr"] = Processor.process_auditKeyRecordStartstrEndstr
    self._processMap["browseKey"] = Processor.process_browseKey
    self._processMap["browseKeys"] = Processor.process_browseKeys
    self._processMap["browseKeyTime"] = Processor.process_browseKeyTime
    self._processMap["browseKeyTimestr"] = Processor.process_browseKeyTimestr
    self._processMap["browseKeysTime"] = Processor.process_browseKeysTime
    self._processMap["browseKeysTimestr"] = Processor.process_browseKeysTimestr
    self._processMap["chronologizeKeyRecord"] = Processor.process_chronologizeKeyRecord
    self._processMap["chronologizeKeyRecordStart"] = Processor.process_chronologizeKeyRecordStart
    self._processMap["chronologizeKeyRecordStartstr"] = Processor.process_chronologizeKeyRecordStartstr
    self._processMap["chronologizeKeyRecordStartEnd"] = Processor.process_chronologizeKeyRecordStartEnd
    self._processMap["chronologizeKeyRecordStartstrEndstr"] = Processor.process_chronologizeKeyRecordStartstrEndstr
    self._processMap["clearRecord"] = Processor.process_clearRecord
    self._processMap["clearRecords"] = Processor.process_clearRecords
    self._processMap["clearKeyRecord"] = Processor.process_clearKeyRecord
    self._processMap["clearKeysRecord"] = Processor.process_clearKeysRecord
    self._processMap["clearKeyRecords"] = Processor.process_clearKeyRecords
    self._processMap["clearKeysRecords"] = Processor.process_clearKeysRecords
    self._processMap["commit"] = Processor.process_commit
    self._processMap["describeRecord"] = Processor.process_describeRecord
    self._processMap["describeRecordTime"] = Processor.process_describeRecordTime
    self._processMap["describeRecordTimestr"] = Processor.process_describeRecordTimestr
    self._processMap["describeRecords"] = Processor.process_describeRecords
    self._processMap["describeRecordsTime"] = Processor.process_describeRecordsTime
    self._processMap["describeRecordsTimestr"] = Processor.process_describeRecordsTimestr
    self._processMap["diffRecordStart"] = Processor.process_diffRecordStart
    self._processMap["diffRecordStartstr"] = Processor.process_diffRecordStartstr
    self._processMap["diffRecordStartEnd"] = Processor.process_diffRecordStartEnd
    self._processMap["diffRecordStartstrEndstr"] = Processor.process_diffRecordStartstrEndstr
    self._processMap["diffKeyRecordStart"] = Processor.process_diffKeyRecordStart
    self._processMap["diffKeyRecordStartstr"] = Processor.process_diffKeyRecordStartstr
    self._processMap["diffKeyRecordStartEnd"] = Processor.process_diffKeyRecordStartEnd
    self._processMap["diffKeyRecordStartstrEndstr"] = Processor.process_diffKeyRecordStartstrEndstr
    self._processMap["diffKeyStart"] = Processor.process_diffKeyStart
    self._processMap["diffKeyStartstr"] = Processor.process_diffKeyStartstr
    self._processMap["diffKeyStartEnd"] = Processor.process_diffKeyStartEnd
    self._processMap["diffKeyStartstrEndstr"] = Processor.process_diffKeyStartstrEndstr
    self._processMap["invokePlugin"] = Processor.process_invokePlugin
    self._processMap["login"] = Processor.process_login
    self._processMap["logout"] = Processor.process_logout
    self._processMap["stage"] = Processor.process_stage
    self._processMap["insertJson"] = Processor.process_insertJson
    self._processMap["insertJsonRecord"] = Processor.process_insertJsonRecord
    self._processMap["insertJsonRecords"] = Processor.process_insertJsonRecords
    self._processMap["removeKeyValueRecord"] = Processor.process_removeKeyValueRecord
    self._processMap["removeKeyValueRecords"] = Processor.process_removeKeyValueRecords
    self._processMap["setKeyValueRecord"] = Processor.process_setKeyValueRecord
    self._processMap["setKeyValue"] = Processor.process_setKeyValue
    self._processMap["setKeyValueRecords"] = Processor.process_setKeyValueRecords
    self._processMap["reconcileKeyRecordValues"] = Processor.process_reconcileKeyRecordValues
    self._processMap["inventory"] = Processor.process_inventory
    self._processMap["selectRecord"] = Processor.process_selectRecord
    self._processMap["selectRecords"] = Processor.process_selectRecords
    self._processMap["selectRecordTime"] = Processor.process_selectRecordTime
    self._processMap["selectRecordTimestr"] = Processor.process_selectRecordTimestr
    self._processMap["selectRecordsTime"] = Processor.process_selectRecordsTime
    self._processMap["selectRecordsTimestr"] = Processor.process_selectRecordsTimestr
    self._processMap["selectKeyRecord"] = Processor.process_selectKeyRecord
    self._processMap["selectKeyRecordTime"] = Processor.process_selectKeyRecordTime
    self._processMap["selectKeyRecordTimestr"] = Processor.process_selectKeyRecordTimestr
    self._processMap["selectKeysRecord"] = Processor.process_selectKeysRecord
    self._processMap["selectKeysRecordTime"] = Processor.process_selectKeysRecordTime
    self._processMap["selectKeysRecordTimestr"] = Processor.process_selectKeysRecordTimestr
    self._processMap["selectKeysRecords"] = Processor.process_selectKeysRecords
    self._processMap["selectKeyRecords"] = Processor.process_selectKeyRecords
    self._processMap["selectKeyRecordsTime"] = Processor.process_selectKeyRecordsTime
    self._processMap["selectKeyRecordsTimestr"] = Processor.process_selectKeyRecordsTimestr
    self._processMap["selectKeysRecordsTime"] = Processor.process_selectKeysRecordsTime
    self._processMap["selectKeysRecordsTimestr"] = Processor.process_selectKeysRecordsTimestr
    self._processMap["selectCriteria"] = Processor.process_selectCriteria
    self._processMap["selectCcl"] = Processor.process_selectCcl
    self._processMap["selectCriteriaTime"] = Processor.process_selectCriteriaTime
    self._processMap["selectCriteriaTimestr"] = Processor.process_selectCriteriaTimestr
    self._processMap["selectCclTime"] = Processor.process_selectCclTime
    self._processMap["selectCclTimestr"] = Processor.process_selectCclTimestr
    self._processMap["selectKeyCriteria"] = Processor.process_selectKeyCriteria
    self._processMap["selectKeyCcl"] = Processor.process_selectKeyCcl
    self._processMap["selectKeyCriteriaTime"] = Processor.process_selectKeyCriteriaTime
    self._processMap["selectKeyCriteriaTimestr"] = Processor.process_selectKeyCriteriaTimestr
    self._processMap["selectKeyCclTime"] = Processor.process_selectKeyCclTime
    self._processMap["selectKeyCclTimestr"] = Processor.process_selectKeyCclTimestr
    self._processMap["selectKeysCriteria"] = Processor.process_selectKeysCriteria
    self._processMap["selectKeysCcl"] = Processor.process_selectKeysCcl
    self._processMap["selectKeysCriteriaTime"] = Processor.process_selectKeysCriteriaTime
    self._processMap["selectKeysCriteriaTimestr"] = Processor.process_selectKeysCriteriaTimestr
    self._processMap["selectKeysCclTime"] = Processor.process_selectKeysCclTime
    self._processMap["selectKeysCclTimestr"] = Processor.process_selectKeysCclTimestr
    self._processMap["getKeyRecord"] = Processor.process_getKeyRecord
    self._processMap["getKeyRecordTime"] = Processor.process_getKeyRecordTime
    self._processMap["getKeyRecordTimestr"] = Processor.process_getKeyRecordTimestr
    self._processMap["getKeysRecord"] = Processor.process_getKeysRecord
    self._processMap["getKeysRecordTime"] = Processor.process_getKeysRecordTime
    self._processMap["getKeysRecordTimestr"] = Processor.process_getKeysRecordTimestr
    self._processMap["getKeysRecords"] = Processor.process_getKeysRecords
    self._processMap["getKeyRecords"] = Processor.process_getKeyRecords
    self._processMap["getKeyRecordsTime"] = Processor.process_getKeyRecordsTime
    self._processMap["getKeyRecordsTimestr"] = Processor.process_getKeyRecordsTimestr
    self._processMap["getKeysRecordsTime"] = Processor.process_getKeysRecordsTime
    self._processMap["getKeysRecordsTimestr"] = Processor.process_getKeysRecordsTimestr
    self._processMap["getKeyCriteria"] = Processor.process_getKeyCriteria
    self._processMap["getCriteria"] = Processor.process_getCriteria
    self._processMap["getCcl"] = Processor.process_getCcl
    self._processMap["getCriteriaTime"] = Processor.process_getCriteriaTime
    self._processMap["getCriteriaTimestr"] = Processor.process_getCriteriaTimestr
    self._processMap["getCclTime"] = Processor.process_getCclTime
    self._processMap["getCclTimestr"] = Processor.process_getCclTimestr
    self._processMap["getKeyCcl"] = Processor.process_getKeyCcl
    self._processMap["getKeyCriteriaTime"] = Processor.process_getKeyCriteriaTime
    self._processMap["getKeyCriteriaTimestr"] = Processor.process_getKeyCriteriaTimestr
    self._processMap["getKeyCclTime"] = Processor.process_getKeyCclTime
    self._processMap["getKeyCclTimestr"] = Processor.process_getKeyCclTimestr
    self._processMap["getKeysCriteria"] = Processor.process_getKeysCriteria
    self._processMap["getKeysCcl"] = Processor.process_getKeysCcl
    self._processMap["getKeysCriteriaTime"] = Processor.process_getKeysCriteriaTime
    self._processMap["getKeysCriteriaTimestr"] = Processor.process_getKeysCriteriaTimestr
    self._processMap["getKeysCclTime"] = Processor.process_getKeysCclTime
    self._processMap["getKeysCclTimestr"] = Processor.process_getKeysCclTimestr
    self._processMap["verifyKeyValueRecord"] = Processor.process_verifyKeyValueRecord
    self._processMap["verifyKeyValueRecordTime"] = Processor.process_verifyKeyValueRecordTime
    self._processMap["verifyKeyValueRecordTimestr"] = Processor.process_verifyKeyValueRecordTimestr
    self._processMap["jsonifyRecords"] = Processor.process_jsonifyRecords
    self._processMap["jsonifyRecordsTime"] = Processor.process_jsonifyRecordsTime
    self._processMap["jsonifyRecordsTimestr"] = Processor.process_jsonifyRecordsTimestr
    self._processMap["findCriteria"] = Processor.process_findCriteria
    self._processMap["findCcl"] = Processor.process_findCcl
    self._processMap["findKeyOperatorValues"] = Processor.process_findKeyOperatorValues
    self._processMap["findKeyOperatorValuesTime"] = Processor.process_findKeyOperatorValuesTime
    self._processMap["findKeyOperatorValuesTimestr"] = Processor.process_findKeyOperatorValuesTimestr
    self._processMap["findKeyOperatorstrValues"] = Processor.process_findKeyOperatorstrValues
    self._processMap["findKeyOperatorstrValuesTime"] = Processor.process_findKeyOperatorstrValuesTime
    self._processMap["findKeyOperatorstrValuesTimestr"] = Processor.process_findKeyOperatorstrValuesTimestr
    self._processMap["search"] = Processor.process_search
    self._processMap["revertKeysRecordsTime"] = Processor.process_revertKeysRecordsTime
    self._processMap["revertKeysRecordsTimestr"] = Processor.process_revertKeysRecordsTimestr
    self._processMap["revertKeysRecordTime"] = Processor.process_revertKeysRecordTime
    self._processMap["revertKeysRecordTimestr"] = Processor.process_revertKeysRecordTimestr
    self._processMap["revertKeyRecordsTime"] = Processor.process_revertKeyRecordsTime
    self._processMap["revertKeyRecordsTimestr"] = Processor.process_revertKeyRecordsTimestr
    self._processMap["revertKeyRecordTime"] = Processor.process_revertKeyRecordTime
    self._processMap["revertKeyRecordTimestr"] = Processor.process_revertKeyRecordTimestr
    self._processMap["pingRecords"] = Processor.process_pingRecords
    self._processMap["pingRecord"] = Processor.process_pingRecord
    self._processMap["verifyAndSwap"] = Processor.process_verifyAndSwap
    self._processMap["verifyOrSet"] = Processor.process_verifyOrSet
    self._processMap["findOrAddKeyValue"] = Processor.process_findOrAddKeyValue
    self._processMap["findOrInsertCriteriaJson"] = Processor.process_findOrInsertCriteriaJson
    self._processMap["findOrInsertCclJson"] = Processor.process_findOrInsertCclJson
    self._processMap["getServerEnvironment"] = Processor.process_getServerEnvironment
    self._processMap["getServerVersion"] = Processor.process_getServerVersion
    self._processMap["time"] = Processor.process_time
    self._processMap["timePhrase"] = Processor.process_timePhrase

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_abort(self, seqid, iprot, oprot):
    args = abort_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = abort_result()
    try:
      self._handler.abort(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("abort", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValue(self, seqid, iprot, oprot):
    args = addKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValue_result()
    try:
      result.success = self._handler.addKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValueRecord(self, seqid, iprot, oprot):
    args = addKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValueRecord_result()
    try:
      result.success = self._handler.addKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addKeyValueRecords(self, seqid, iprot, oprot):
    args = addKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addKeyValueRecords_result()
    try:
      result.success = self._handler.addKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("addKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecord(self, seqid, iprot, oprot):
    args = auditRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecord_result()
    try:
      result.success = self._handler.auditRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStart(self, seqid, iprot, oprot):
    args = auditRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStart_result()
    try:
      result.success = self._handler.auditRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartstr(self, seqid, iprot, oprot):
    args = auditRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartstr_result()
    try:
      result.success = self._handler.auditRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartEnd(self, seqid, iprot, oprot):
    args = auditRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartEnd_result()
    try:
      result.success = self._handler.auditRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = auditRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditRecordStartstrEndstr_result()
    try:
      result.success = self._handler.auditRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecord(self, seqid, iprot, oprot):
    args = auditKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecord_result()
    try:
      result.success = self._handler.auditKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStart(self, seqid, iprot, oprot):
    args = auditKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStart_result()
    try:
      result.success = self._handler.auditKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartstr(self, seqid, iprot, oprot):
    args = auditKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartstr_result()
    try:
      result.success = self._handler.auditKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = auditKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartEnd_result()
    try:
      result.success = self._handler.auditKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_auditKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = auditKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = auditKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.auditKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("auditKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKey(self, seqid, iprot, oprot):
    args = browseKey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKey_result()
    try:
      result.success = self._handler.browseKey(args.key, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKey", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeys(self, seqid, iprot, oprot):
    args = browseKeys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeys_result()
    try:
      result.success = self._handler.browseKeys(args.keys, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeys", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeyTime(self, seqid, iprot, oprot):
    args = browseKeyTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeyTime_result()
    try:
      result.success = self._handler.browseKeyTime(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeyTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeyTimestr(self, seqid, iprot, oprot):
    args = browseKeyTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeyTimestr_result()
    try:
      result.success = self._handler.browseKeyTimestr(args.key, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeyTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeysTime(self, seqid, iprot, oprot):
    args = browseKeysTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeysTime_result()
    try:
      result.success = self._handler.browseKeysTime(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeysTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_browseKeysTimestr(self, seqid, iprot, oprot):
    args = browseKeysTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = browseKeysTimestr_result()
    try:
      result.success = self._handler.browseKeysTimestr(args.keys, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("browseKeysTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecord(self, seqid, iprot, oprot):
    args = chronologizeKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecord_result()
    try:
      result.success = self._handler.chronologizeKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStart(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStart_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartstr(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartstr_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartEnd_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_chronologizeKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = chronologizeKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = chronologizeKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.chronologizeKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("chronologizeKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearRecord(self, seqid, iprot, oprot):
    args = clearRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearRecord_result()
    try:
      self._handler.clearRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearRecords(self, seqid, iprot, oprot):
    args = clearRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearRecords_result()
    try:
      self._handler.clearRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeyRecord(self, seqid, iprot, oprot):
    args = clearKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeyRecord_result()
    try:
      self._handler.clearKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeysRecord(self, seqid, iprot, oprot):
    args = clearKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeysRecord_result()
    try:
      self._handler.clearKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeyRecords(self, seqid, iprot, oprot):
    args = clearKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeyRecords_result()
    try:
      self._handler.clearKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearKeysRecords(self, seqid, iprot, oprot):
    args = clearKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearKeysRecords_result()
    try:
      self._handler.clearKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("clearKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit(self, seqid, iprot, oprot):
    args = commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_result()
    try:
      result.success = self._handler.commit(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("commit", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecord(self, seqid, iprot, oprot):
    args = describeRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecord_result()
    try:
      result.success = self._handler.describeRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordTime(self, seqid, iprot, oprot):
    args = describeRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordTime_result()
    try:
      result.success = self._handler.describeRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordTimestr(self, seqid, iprot, oprot):
    args = describeRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordTimestr_result()
    try:
      result.success = self._handler.describeRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecords(self, seqid, iprot, oprot):
    args = describeRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecords_result()
    try:
      result.success = self._handler.describeRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordsTime(self, seqid, iprot, oprot):
    args = describeRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordsTime_result()
    try:
      result.success = self._handler.describeRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeRecordsTimestr(self, seqid, iprot, oprot):
    args = describeRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeRecordsTimestr_result()
    try:
      result.success = self._handler.describeRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("describeRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStart(self, seqid, iprot, oprot):
    args = diffRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStart_result()
    try:
      result.success = self._handler.diffRecordStart(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartstr(self, seqid, iprot, oprot):
    args = diffRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartstr_result()
    try:
      result.success = self._handler.diffRecordStartstr(args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartEnd(self, seqid, iprot, oprot):
    args = diffRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartEnd_result()
    try:
      result.success = self._handler.diffRecordStartEnd(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = diffRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffRecordStartstrEndstr_result()
    try:
      result.success = self._handler.diffRecordStartstrEndstr(args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStart(self, seqid, iprot, oprot):
    args = diffKeyRecordStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStart_result()
    try:
      result.success = self._handler.diffKeyRecordStart(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartstr(self, seqid, iprot, oprot):
    args = diffKeyRecordStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartstr_result()
    try:
      result.success = self._handler.diffKeyRecordStartstr(args.key, args.record, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartEnd(self, seqid, iprot, oprot):
    args = diffKeyRecordStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartEnd_result()
    try:
      result.success = self._handler.diffKeyRecordStartEnd(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyRecordStartstrEndstr(self, seqid, iprot, oprot):
    args = diffKeyRecordStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyRecordStartstrEndstr_result()
    try:
      result.success = self._handler.diffKeyRecordStartstrEndstr(args.key, args.record, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyRecordStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStart(self, seqid, iprot, oprot):
    args = diffKeyStart_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStart_result()
    try:
      result.success = self._handler.diffKeyStart(args.key, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStart", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartstr(self, seqid, iprot, oprot):
    args = diffKeyStartstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartstr_result()
    try:
      result.success = self._handler.diffKeyStartstr(args.key, args.start, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartEnd(self, seqid, iprot, oprot):
    args = diffKeyStartEnd_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartEnd_result()
    try:
      result.success = self._handler.diffKeyStartEnd(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartEnd", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diffKeyStartstrEndstr(self, seqid, iprot, oprot):
    args = diffKeyStartstrEndstr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diffKeyStartstrEndstr_result()
    try:
      result.success = self._handler.diffKeyStartstrEndstr(args.key, args.start, args.tend, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("diffKeyStartstrEndstr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_invokePlugin(self, seqid, iprot, oprot):
    args = invokePlugin_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = invokePlugin_result()
    try:
      result.success = self._handler.invokePlugin(args.id, args.method, args.params, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("invokePlugin", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_login(self, seqid, iprot, oprot):
    args = login_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = login_result()
    try:
      result.success = self._handler.login(args.username, args.password, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("login", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_logout(self, seqid, iprot, oprot):
    args = logout_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = logout_result()
    try:
      self._handler.logout(args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("logout", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stage(self, seqid, iprot, oprot):
    args = stage_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stage_result()
    try:
      result.success = self._handler.stage(args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("stage", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJson(self, seqid, iprot, oprot):
    args = insertJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJson_result()
    try:
      result.success = self._handler.insertJson(args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJsonRecord(self, seqid, iprot, oprot):
    args = insertJsonRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJsonRecord_result()
    try:
      result.success = self._handler.insertJsonRecord(args.json, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJsonRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insertJsonRecords(self, seqid, iprot, oprot):
    args = insertJsonRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insertJsonRecords_result()
    try:
      result.success = self._handler.insertJsonRecords(args.json, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("insertJsonRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeKeyValueRecord(self, seqid, iprot, oprot):
    args = removeKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeKeyValueRecord_result()
    try:
      result.success = self._handler.removeKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeKeyValueRecords(self, seqid, iprot, oprot):
    args = removeKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeKeyValueRecords_result()
    try:
      result.success = self._handler.removeKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("removeKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValueRecord(self, seqid, iprot, oprot):
    args = setKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValueRecord_result()
    try:
      self._handler.setKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValue(self, seqid, iprot, oprot):
    args = setKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValue_result()
    try:
      result.success = self._handler.setKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setKeyValueRecords(self, seqid, iprot, oprot):
    args = setKeyValueRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setKeyValueRecords_result()
    try:
      self._handler.setKeyValueRecords(args.key, args.value, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("setKeyValueRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_reconcileKeyRecordValues(self, seqid, iprot, oprot):
    args = reconcileKeyRecordValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = reconcileKeyRecordValues_result()
    try:
      self._handler.reconcileKeyRecordValues(args.key, args.record, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("reconcileKeyRecordValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_inventory(self, seqid, iprot, oprot):
    args = inventory_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = inventory_result()
    try:
      result.success = self._handler.inventory(args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("inventory", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecord(self, seqid, iprot, oprot):
    args = selectRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecord_result()
    try:
      result.success = self._handler.selectRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecords(self, seqid, iprot, oprot):
    args = selectRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecords_result()
    try:
      result.success = self._handler.selectRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordTime(self, seqid, iprot, oprot):
    args = selectRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordTime_result()
    try:
      result.success = self._handler.selectRecordTime(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordTimestr(self, seqid, iprot, oprot):
    args = selectRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordTimestr_result()
    try:
      result.success = self._handler.selectRecordTimestr(args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordsTime(self, seqid, iprot, oprot):
    args = selectRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordsTime_result()
    try:
      result.success = self._handler.selectRecordsTime(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectRecordsTimestr(self, seqid, iprot, oprot):
    args = selectRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectRecordsTimestr_result()
    try:
      result.success = self._handler.selectRecordsTimestr(args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecord(self, seqid, iprot, oprot):
    args = selectKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecord_result()
    try:
      result.success = self._handler.selectKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordTime(self, seqid, iprot, oprot):
    args = selectKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordTime_result()
    try:
      result.success = self._handler.selectKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordTimestr(self, seqid, iprot, oprot):
    args = selectKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordTimestr_result()
    try:
      result.success = self._handler.selectKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecord(self, seqid, iprot, oprot):
    args = selectKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecord_result()
    try:
      result.success = self._handler.selectKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordTime(self, seqid, iprot, oprot):
    args = selectKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordTime_result()
    try:
      result.success = self._handler.selectKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordTimestr(self, seqid, iprot, oprot):
    args = selectKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordTimestr_result()
    try:
      result.success = self._handler.selectKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecords(self, seqid, iprot, oprot):
    args = selectKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecords_result()
    try:
      result.success = self._handler.selectKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecords(self, seqid, iprot, oprot):
    args = selectKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecords_result()
    try:
      result.success = self._handler.selectKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordsTime(self, seqid, iprot, oprot):
    args = selectKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordsTime_result()
    try:
      result.success = self._handler.selectKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = selectKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyRecordsTimestr_result()
    try:
      result.success = self._handler.selectKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordsTime(self, seqid, iprot, oprot):
    args = selectKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordsTime_result()
    try:
      result.success = self._handler.selectKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = selectKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysRecordsTimestr_result()
    try:
      result.success = self._handler.selectKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteria(self, seqid, iprot, oprot):
    args = selectCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteria_result()
    try:
      result.success = self._handler.selectCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCcl(self, seqid, iprot, oprot):
    args = selectCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCcl_result()
    try:
      result.success = self._handler.selectCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteriaTime(self, seqid, iprot, oprot):
    args = selectCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteriaTime_result()
    try:
      result.success = self._handler.selectCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCriteriaTimestr_result()
    try:
      result.success = self._handler.selectCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCclTime(self, seqid, iprot, oprot):
    args = selectCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCclTime_result()
    try:
      result.success = self._handler.selectCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectCclTimestr(self, seqid, iprot, oprot):
    args = selectCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectCclTimestr_result()
    try:
      result.success = self._handler.selectCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteria(self, seqid, iprot, oprot):
    args = selectKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteria_result()
    try:
      result.success = self._handler.selectKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCcl(self, seqid, iprot, oprot):
    args = selectKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCcl_result()
    try:
      result.success = self._handler.selectKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteriaTime(self, seqid, iprot, oprot):
    args = selectKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteriaTime_result()
    try:
      result.success = self._handler.selectKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.selectKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCclTime(self, seqid, iprot, oprot):
    args = selectKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCclTime_result()
    try:
      result.success = self._handler.selectKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeyCclTimestr(self, seqid, iprot, oprot):
    args = selectKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeyCclTimestr_result()
    try:
      result.success = self._handler.selectKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteria(self, seqid, iprot, oprot):
    args = selectKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteria_result()
    try:
      result.success = self._handler.selectKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCcl(self, seqid, iprot, oprot):
    args = selectKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCcl_result()
    try:
      result.success = self._handler.selectKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteriaTime(self, seqid, iprot, oprot):
    args = selectKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteriaTime_result()
    try:
      result.success = self._handler.selectKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = selectKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.selectKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCclTime(self, seqid, iprot, oprot):
    args = selectKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCclTime_result()
    try:
      result.success = self._handler.selectKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_selectKeysCclTimestr(self, seqid, iprot, oprot):
    args = selectKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = selectKeysCclTimestr_result()
    try:
      result.success = self._handler.selectKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("selectKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecord(self, seqid, iprot, oprot):
    args = getKeyRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecord_result()
    try:
      result.success = self._handler.getKeyRecord(args.key, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordTime(self, seqid, iprot, oprot):
    args = getKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordTime_result()
    try:
      result.success = self._handler.getKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordTimestr(self, seqid, iprot, oprot):
    args = getKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordTimestr_result()
    try:
      result.success = self._handler.getKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecord(self, seqid, iprot, oprot):
    args = getKeysRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecord_result()
    try:
      result.success = self._handler.getKeysRecord(args.keys, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordTime(self, seqid, iprot, oprot):
    args = getKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordTime_result()
    try:
      result.success = self._handler.getKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordTimestr(self, seqid, iprot, oprot):
    args = getKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordTimestr_result()
    try:
      result.success = self._handler.getKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecords(self, seqid, iprot, oprot):
    args = getKeysRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecords_result()
    try:
      result.success = self._handler.getKeysRecords(args.keys, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecords(self, seqid, iprot, oprot):
    args = getKeyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecords_result()
    try:
      result.success = self._handler.getKeyRecords(args.key, args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordsTime(self, seqid, iprot, oprot):
    args = getKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordsTime_result()
    try:
      result.success = self._handler.getKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = getKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyRecordsTimestr_result()
    try:
      result.success = self._handler.getKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordsTime(self, seqid, iprot, oprot):
    args = getKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordsTime_result()
    try:
      result.success = self._handler.getKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = getKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysRecordsTimestr_result()
    try:
      result.success = self._handler.getKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteria(self, seqid, iprot, oprot):
    args = getKeyCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteria_result()
    try:
      result.success = self._handler.getKeyCriteria(args.key, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteria(self, seqid, iprot, oprot):
    args = getCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteria_result()
    try:
      result.success = self._handler.getCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCcl(self, seqid, iprot, oprot):
    args = getCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCcl_result()
    try:
      result.success = self._handler.getCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteriaTime(self, seqid, iprot, oprot):
    args = getCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteriaTime_result()
    try:
      result.success = self._handler.getCriteriaTime(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCriteriaTimestr(self, seqid, iprot, oprot):
    args = getCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCriteriaTimestr_result()
    try:
      result.success = self._handler.getCriteriaTimestr(args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCclTime(self, seqid, iprot, oprot):
    args = getCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCclTime_result()
    try:
      result.success = self._handler.getCclTime(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCclTimestr(self, seqid, iprot, oprot):
    args = getCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCclTimestr_result()
    try:
      result.success = self._handler.getCclTimestr(args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCcl(self, seqid, iprot, oprot):
    args = getKeyCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCcl_result()
    try:
      result.success = self._handler.getKeyCcl(args.key, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteriaTime(self, seqid, iprot, oprot):
    args = getKeyCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteriaTime_result()
    try:
      result.success = self._handler.getKeyCriteriaTime(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCriteriaTimestr(self, seqid, iprot, oprot):
    args = getKeyCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCriteriaTimestr_result()
    try:
      result.success = self._handler.getKeyCriteriaTimestr(args.key, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCclTime(self, seqid, iprot, oprot):
    args = getKeyCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCclTime_result()
    try:
      result.success = self._handler.getKeyCclTime(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeyCclTimestr(self, seqid, iprot, oprot):
    args = getKeyCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeyCclTimestr_result()
    try:
      result.success = self._handler.getKeyCclTimestr(args.key, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeyCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteria(self, seqid, iprot, oprot):
    args = getKeysCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteria_result()
    try:
      result.success = self._handler.getKeysCriteria(args.keys, args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCcl(self, seqid, iprot, oprot):
    args = getKeysCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCcl_result()
    try:
      result.success = self._handler.getKeysCcl(args.keys, args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteriaTime(self, seqid, iprot, oprot):
    args = getKeysCriteriaTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteriaTime_result()
    try:
      result.success = self._handler.getKeysCriteriaTime(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteriaTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCriteriaTimestr(self, seqid, iprot, oprot):
    args = getKeysCriteriaTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCriteriaTimestr_result()
    try:
      result.success = self._handler.getKeysCriteriaTimestr(args.keys, args.criteria, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCriteriaTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCclTime(self, seqid, iprot, oprot):
    args = getKeysCclTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCclTime_result()
    try:
      result.success = self._handler.getKeysCclTime(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCclTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getKeysCclTimestr(self, seqid, iprot, oprot):
    args = getKeysCclTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getKeysCclTimestr_result()
    try:
      result.success = self._handler.getKeysCclTimestr(args.keys, args.ccl, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getKeysCclTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecord(self, seqid, iprot, oprot):
    args = verifyKeyValueRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecord_result()
    try:
      result.success = self._handler.verifyKeyValueRecord(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecordTime(self, seqid, iprot, oprot):
    args = verifyKeyValueRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecordTime_result()
    try:
      result.success = self._handler.verifyKeyValueRecordTime(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyKeyValueRecordTimestr(self, seqid, iprot, oprot):
    args = verifyKeyValueRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyKeyValueRecordTimestr_result()
    try:
      result.success = self._handler.verifyKeyValueRecordTimestr(args.key, args.value, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyKeyValueRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecords(self, seqid, iprot, oprot):
    args = jsonifyRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecords_result()
    try:
      result.success = self._handler.jsonifyRecords(args.records, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecordsTime(self, seqid, iprot, oprot):
    args = jsonifyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecordsTime_result()
    try:
      result.success = self._handler.jsonifyRecordsTime(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_jsonifyRecordsTimestr(self, seqid, iprot, oprot):
    args = jsonifyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = jsonifyRecordsTimestr_result()
    try:
      result.success = self._handler.jsonifyRecordsTimestr(args.records, args.timestamp, args.identifier, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("jsonifyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findCriteria(self, seqid, iprot, oprot):
    args = findCriteria_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findCriteria_result()
    try:
      result.success = self._handler.findCriteria(args.criteria, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findCriteria", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findCcl(self, seqid, iprot, oprot):
    args = findCcl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findCcl_result()
    try:
      result.success = self._handler.findCcl(args.ccl, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findCcl", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValues(self, seqid, iprot, oprot):
    args = findKeyOperatorValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValues_result()
    try:
      result.success = self._handler.findKeyOperatorValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValuesTime(self, seqid, iprot, oprot):
    args = findKeyOperatorValuesTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValuesTime_result()
    try:
      result.success = self._handler.findKeyOperatorValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValuesTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorValuesTimestr(self, seqid, iprot, oprot):
    args = findKeyOperatorValuesTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorValuesTimestr_result()
    try:
      result.success = self._handler.findKeyOperatorValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorValuesTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValues(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValues_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValues_result()
    try:
      result.success = self._handler.findKeyOperatorstrValues(args.key, args.operator, args.values, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValues", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValuesTime(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValuesTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValuesTime_result()
    try:
      result.success = self._handler.findKeyOperatorstrValuesTime(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValuesTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findKeyOperatorstrValuesTimestr(self, seqid, iprot, oprot):
    args = findKeyOperatorstrValuesTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findKeyOperatorstrValuesTimestr_result()
    try:
      result.success = self._handler.findKeyOperatorstrValuesTimestr(args.key, args.operator, args.values, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findKeyOperatorstrValuesTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search(self, seqid, iprot, oprot):
    args = search_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_result()
    try:
      result.success = self._handler.search(args.key, args.query, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("search", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordsTime(self, seqid, iprot, oprot):
    args = revertKeysRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordsTime_result()
    try:
      self._handler.revertKeysRecordsTime(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordsTimestr(self, seqid, iprot, oprot):
    args = revertKeysRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordsTimestr_result()
    try:
      self._handler.revertKeysRecordsTimestr(args.keys, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordTime(self, seqid, iprot, oprot):
    args = revertKeysRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordTime_result()
    try:
      self._handler.revertKeysRecordTime(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeysRecordTimestr(self, seqid, iprot, oprot):
    args = revertKeysRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeysRecordTimestr_result()
    try:
      self._handler.revertKeysRecordTimestr(args.keys, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeysRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordsTime(self, seqid, iprot, oprot):
    args = revertKeyRecordsTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordsTime_result()
    try:
      self._handler.revertKeyRecordsTime(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordsTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordsTimestr(self, seqid, iprot, oprot):
    args = revertKeyRecordsTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordsTimestr_result()
    try:
      self._handler.revertKeyRecordsTimestr(args.key, args.records, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordsTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordTime(self, seqid, iprot, oprot):
    args = revertKeyRecordTime_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordTime_result()
    try:
      self._handler.revertKeyRecordTime(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordTime", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_revertKeyRecordTimestr(self, seqid, iprot, oprot):
    args = revertKeyRecordTimestr_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = revertKeyRecordTimestr_result()
    try:
      self._handler.revertKeyRecordTimestr(args.key, args.record, args.timestamp, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("revertKeyRecordTimestr", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingRecords(self, seqid, iprot, oprot):
    args = pingRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingRecords_result()
    try:
      result.success = self._handler.pingRecords(args.records, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pingRecords", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_pingRecord(self, seqid, iprot, oprot):
    args = pingRecord_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = pingRecord_result()
    try:
      result.success = self._handler.pingRecord(args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("pingRecord", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyAndSwap(self, seqid, iprot, oprot):
    args = verifyAndSwap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyAndSwap_result()
    try:
      result.success = self._handler.verifyAndSwap(args.key, args.expected, args.record, args.replacement, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyAndSwap", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_verifyOrSet(self, seqid, iprot, oprot):
    args = verifyOrSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = verifyOrSet_result()
    try:
      self._handler.verifyOrSet(args.key, args.value, args.record, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except InvalidArgumentException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("verifyOrSet", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrAddKeyValue(self, seqid, iprot, oprot):
    args = findOrAddKeyValue_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrAddKeyValue_result()
    try:
      result.success = self._handler.findOrAddKeyValue(args.key, args.value, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except DuplicateEntryException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except InvalidArgumentException as ex4:
      msg_type = TMessageType.REPLY
      result.ex4 = ex4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrAddKeyValue", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrInsertCriteriaJson(self, seqid, iprot, oprot):
    args = findOrInsertCriteriaJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrInsertCriteriaJson_result()
    try:
      result.success = self._handler.findOrInsertCriteriaJson(args.criteria, args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except DuplicateEntryException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrInsertCriteriaJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_findOrInsertCclJson(self, seqid, iprot, oprot):
    args = findOrInsertCclJson_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = findOrInsertCclJson_result()
    try:
      result.success = self._handler.findOrInsertCclJson(args.ccl, args.json, args.creds, args.transaction, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except DuplicateEntryException as ex4:
      msg_type = TMessageType.REPLY
      result.ex4 = ex4
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("findOrInsertCclJson", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerEnvironment(self, seqid, iprot, oprot):
    args = getServerEnvironment_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerEnvironment_result()
    try:
      result.success = self._handler.getServerEnvironment(args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getServerEnvironment", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getServerVersion(self, seqid, iprot, oprot):
    args = getServerVersion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerVersion_result()
    try:
      result.success = self._handler.getServerVersion()
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("getServerVersion", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_time(self, seqid, iprot, oprot):
    args = time_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = time_result()
    try:
      result.success = self._handler.time(args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("time", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_timePhrase(self, seqid, iprot, oprot):
    args = timePhrase_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = timePhrase_result()
    try:
      result.success = self._handler.timePhrase(args.phrase, args.creds, args.token, args.environment)
      msg_type = TMessageType.REPLY
    except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
      raise
    except SecurityException as ex:
      msg_type = TMessageType.REPLY
      result.ex = ex
    except TransactionException as ex2:
      msg_type = TMessageType.REPLY
      result.ex2 = ex2
    except ParseException as ex3:
      msg_type = TMessageType.REPLY
      result.ex3 = ex3
    except Exception as ex:
      msg_type = TMessageType.EXCEPTION
      logging.exception(ex)
      result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
    oprot.writeMessageBegin("timePhrase", msg_type, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class abort_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class abort_result:
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('abort_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in range(_size0):
            _elem5 = iprot.readI64()
            self.records.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter6 in self.records:
        oprot.writeI64(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addKeyValueRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in range(_size7):
            _key12 = iprot.readI64()
            _val13 = iprot.readBool()
            self.success[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addKeyValueRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter14,viter15 in list(self.success.items()):
        oprot.writeI64(kiter14)
        oprot.writeBool(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin()
          for _i20 in range(_size16):
            _key21 = iprot.readI64()
            _val22 = iprot.readString()
            self.success[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter23,viter24 in list(self.success.items()):
        oprot.writeI64(kiter23)
        oprot.writeString(viter24)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStart_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStart_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype26, _vtype27, _size25 ) = iprot.readMapBegin()
          for _i29 in range(_size25):
            _key30 = iprot.readI64()
            _val31 = iprot.readString()
            self.success[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter32,viter33 in list(self.success.items()):
        oprot.writeI64(kiter32)
        oprot.writeString(viter33)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstr_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
          for _i38 in range(_size34):
            _key39 = iprot.readI64()
            _val40 = iprot.readString()
            self.success[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter41,viter42 in list(self.success.items()):
        oprot.writeI64(kiter41)
        oprot.writeString(viter42)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartEnd_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartEnd_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype44, _vtype45, _size43 ) = iprot.readMapBegin()
          for _i47 in range(_size43):
            _key48 = iprot.readI64()
            _val49 = iprot.readString()
            self.success[_key48] = _val49
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter50,viter51 in list(self.success.items()):
        oprot.writeI64(kiter50)
        oprot.writeString(viter51)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstrEndstr_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstrEndstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin()
          for _i56 in range(_size52):
            _key57 = iprot.readI64()
            _val58 = iprot.readString()
            self.success[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter59,viter60 in list(self.success.items()):
        oprot.writeI64(kiter59)
        oprot.writeString(viter60)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype62, _vtype63, _size61 ) = iprot.readMapBegin()
          for _i65 in range(_size61):
            _key66 = iprot.readI64()
            _val67 = iprot.readString()
            self.success[_key66] = _val67
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter68,viter69 in list(self.success.items()):
        oprot.writeI64(kiter68)
        oprot.writeString(viter69)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin()
          for _i74 in range(_size70):
            _key75 = iprot.readI64()
            _val76 = iprot.readString()
            self.success[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter77,viter78 in list(self.success.items()):
        oprot.writeI64(kiter77)
        oprot.writeString(viter78)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin()
          for _i83 in range(_size79):
            _key84 = iprot.readI64()
            _val85 = iprot.readString()
            self.success[_key84] = _val85
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter86,viter87 in list(self.success.items()):
        oprot.writeI64(kiter86)
        oprot.writeString(viter87)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype89, _vtype90, _size88 ) = iprot.readMapBegin()
          for _i92 in range(_size88):
            _key93 = iprot.readI64()
            _val94 = iprot.readString()
            self.success[_key93] = _val94
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter95,viter96 in list(self.success.items()):
        oprot.writeI64(kiter95)
        oprot.writeString(viter96)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class auditKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype98, _vtype99, _size97 ) = iprot.readMapBegin()
          for _i101 in range(_size97):
            _key102 = iprot.readI64()
            _val103 = iprot.readString()
            self.success[_key102] = _val103
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('auditKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
      for kiter104,viter105 in list(self.success.items()):
        oprot.writeI64(kiter104)
        oprot.writeString(viter105)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKey_args:
  """
  Attributes:
   - key
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, key=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKey_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKey_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype107, _vtype108, _size106 ) = iprot.readMapBegin()
          for _i110 in range(_size106):
            _key111 = TObject()
            _key111.read(iprot)
            _val112 = []
            (_etype116, _size113) = iprot.readSetBegin()
            for _i117 in range(_size113):
              _elem118 = iprot.readI64()
              _val112.append(_elem118)
            iprot.readSetEnd()
            self.success[_key111] = _val112
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter119,viter120 in list(self.success.items()):
        kiter119.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter120))
        for iter121 in viter120:
          oprot.writeI64(iter121)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeys_args:
  """
  Attributes:
   - keys
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, keys=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype125, _size122) = iprot.readListBegin()
          for _i126 in range(_size122):
            _elem127 = iprot.readString()
            self.keys.append(_elem127)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeys_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter128 in self.keys:
        oprot.writeString(iter128)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeys_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype130, _vtype131, _size129 ) = iprot.readMapBegin()
          for _i133 in range(_size129):
            _key134 = iprot.readString()
            _val135 = {}
            (_ktype137, _vtype138, _size136 ) = iprot.readMapBegin()
            for _i140 in range(_size136):
              _key141 = TObject()
              _key141.read(iprot)
              _val142 = []
              (_etype146, _size143) = iprot.readSetBegin()
              for _i147 in range(_size143):
                _elem148 = iprot.readI64()
                _val142.append(_elem148)
              iprot.readSetEnd()
              _val135[_key141] = _val142
            iprot.readMapEnd()
            self.success[_key134] = _val135
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter149,viter150 in list(self.success.items()):
        oprot.writeString(kiter149)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter150))
        for kiter151,viter152 in list(viter150.items()):
          kiter151.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter152))
          for iter153 in viter152:
            oprot.writeI64(iter153)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTime_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype155, _vtype156, _size154 ) = iprot.readMapBegin()
          for _i158 in range(_size154):
            _key159 = TObject()
            _key159.read(iprot)
            _val160 = []
            (_etype164, _size161) = iprot.readSetBegin()
            for _i165 in range(_size161):
              _elem166 = iprot.readI64()
              _val160.append(_elem166)
            iprot.readSetEnd()
            self.success[_key159] = _val160
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter167,viter168 in list(self.success.items()):
        kiter167.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter168))
        for iter169 in viter168:
          oprot.writeI64(iter169)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTimestr_args:
  """
  Attributes:
   - key
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeyTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype171, _vtype172, _size170 ) = iprot.readMapBegin()
          for _i174 in range(_size170):
            _key175 = TObject()
            _key175.read(iprot)
            _val176 = []
            (_etype180, _size177) = iprot.readSetBegin()
            for _i181 in range(_size177):
              _elem182 = iprot.readI64()
              _val176.append(_elem182)
            iprot.readSetEnd()
            self.success[_key175] = _val176
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeyTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.SET, len(self.success))
      for kiter183,viter184 in list(self.success.items()):
        kiter183.write(oprot)
        oprot.writeSetBegin(TType.I64, len(viter184))
        for iter185 in viter184:
          oprot.writeI64(iter185)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTime_args:
  """
  Attributes:
   - keys
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype189, _size186) = iprot.readListBegin()
          for _i190 in range(_size186):
            _elem191 = iprot.readString()
            self.keys.append(_elem191)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter192 in self.keys:
        oprot.writeString(iter192)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype194, _vtype195, _size193 ) = iprot.readMapBegin()
          for _i197 in range(_size193):
            _key198 = iprot.readString()
            _val199 = {}
            (_ktype201, _vtype202, _size200 ) = iprot.readMapBegin()
            for _i204 in range(_size200):
              _key205 = TObject()
              _key205.read(iprot)
              _val206 = []
              (_etype210, _size207) = iprot.readSetBegin()
              for _i211 in range(_size207):
                _elem212 = iprot.readI64()
                _val206.append(_elem212)
              iprot.readSetEnd()
              _val199[_key205] = _val206
            iprot.readMapEnd()
            self.success[_key198] = _val199
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter213,viter214 in list(self.success.items()):
        oprot.writeString(kiter213)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter214))
        for kiter215,viter216 in list(viter214.items()):
          kiter215.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter216))
          for iter217 in viter216:
            oprot.writeI64(iter217)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTimestr_args:
  """
  Attributes:
   - keys
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype221, _size218) = iprot.readListBegin()
          for _i222 in range(_size218):
            _elem223 = iprot.readString()
            self.keys.append(_elem223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter224 in self.keys:
        oprot.writeString(iter224)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class browseKeysTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.STRUCT,(TObject, TObject.thrift_spec),TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype226, _vtype227, _size225 ) = iprot.readMapBegin()
          for _i229 in range(_size225):
            _key230 = iprot.readString()
            _val231 = {}
            (_ktype233, _vtype234, _size232 ) = iprot.readMapBegin()
            for _i236 in range(_size232):
              _key237 = TObject()
              _key237.read(iprot)
              _val238 = []
              (_etype242, _size239) = iprot.readSetBegin()
              for _i243 in range(_size239):
                _elem244 = iprot.readI64()
                _val238.append(_elem244)
              iprot.readSetEnd()
              _val231[_key237] = _val238
            iprot.readMapEnd()
            self.success[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('browseKeysTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter245,viter246 in list(self.success.items()):
        oprot.writeString(kiter245)
        oprot.writeMapBegin(TType.STRUCT, TType.SET, len(viter246))
        for kiter247,viter248 in list(viter246.items()):
          kiter247.write(oprot)
          oprot.writeSetBegin(TType.I64, len(viter248))
          for iter249 in viter248:
            oprot.writeI64(iter249)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype251, _vtype252, _size250 ) = iprot.readMapBegin()
          for _i254 in range(_size250):
            _key255 = iprot.readI64()
            _val256 = []
            (_etype260, _size257) = iprot.readSetBegin()
            for _i261 in range(_size257):
              _elem262 = TObject()
              _elem262.read(iprot)
              _val256.append(_elem262)
            iprot.readSetEnd()
            self.success[_key255] = _val256
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter263,viter264 in list(self.success.items()):
        oprot.writeI64(kiter263)
        oprot.writeSetBegin(TType.STRUCT, len(viter264))
        for iter265 in viter264:
          iter265.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype267, _vtype268, _size266 ) = iprot.readMapBegin()
          for _i270 in range(_size266):
            _key271 = iprot.readI64()
            _val272 = []
            (_etype276, _size273) = iprot.readSetBegin()
            for _i277 in range(_size273):
              _elem278 = TObject()
              _elem278.read(iprot)
              _val272.append(_elem278)
            iprot.readSetEnd()
            self.success[_key271] = _val272
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter279,viter280 in list(self.success.items()):
        oprot.writeI64(kiter279)
        oprot.writeSetBegin(TType.STRUCT, len(viter280))
        for iter281 in viter280:
          iter281.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype283, _vtype284, _size282 ) = iprot.readMapBegin()
          for _i286 in range(_size282):
            _key287 = iprot.readI64()
            _val288 = []
            (_etype292, _size289) = iprot.readSetBegin()
            for _i293 in range(_size289):
              _elem294 = TObject()
              _elem294.read(iprot)
              _val288.append(_elem294)
            iprot.readSetEnd()
            self.success[_key287] = _val288
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter295,viter296 in list(self.success.items()):
        oprot.writeI64(kiter295)
        oprot.writeSetBegin(TType.STRUCT, len(viter296))
        for iter297 in viter296:
          iter297.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype299, _vtype300, _size298 ) = iprot.readMapBegin()
          for _i302 in range(_size298):
            _key303 = iprot.readI64()
            _val304 = []
            (_etype308, _size305) = iprot.readSetBegin()
            for _i309 in range(_size305):
              _elem310 = TObject()
              _elem310.read(iprot)
              _val304.append(_elem310)
            iprot.readSetEnd()
            self.success[_key303] = _val304
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter311,viter312 in list(self.success.items()):
        oprot.writeI64(kiter311)
        oprot.writeSetBegin(TType.STRUCT, len(viter312))
        for iter313 in viter312:
          iter313.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class chronologizeKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype315, _vtype316, _size314 ) = iprot.readMapBegin()
          for _i318 in range(_size314):
            _key319 = iprot.readI64()
            _val320 = []
            (_etype324, _size321) = iprot.readSetBegin()
            for _i325 in range(_size321):
              _elem326 = TObject()
              _elem326.read(iprot)
              _val320.append(_elem326)
            iprot.readSetEnd()
            self.success[_key319] = _val320
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('chronologizeKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter327,viter328 in list(self.success.items()):
        oprot.writeI64(kiter327)
        oprot.writeSetBegin(TType.STRUCT, len(viter328))
        for iter329 in viter328:
          iter329.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype333, _size330) = iprot.readListBegin()
          for _i334 in range(_size330):
            _elem335 = iprot.readI64()
            self.records.append(_elem335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter336 in self.records:
        oprot.writeI64(iter336)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype340, _size337) = iprot.readListBegin()
          for _i341 in range(_size337):
            _elem342 = iprot.readString()
            self.keys.append(_elem342)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter343 in self.keys:
        oprot.writeString(iter343)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecord_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype347, _size344) = iprot.readListBegin()
          for _i348 in range(_size344):
            _elem349 = iprot.readI64()
            self.records.append(_elem349)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter350 in self.records:
        oprot.writeI64(iter350)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeyRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeyRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype354, _size351) = iprot.readListBegin()
          for _i355 in range(_size351):
            _elem356 = iprot.readString()
            self.keys.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype360, _size357) = iprot.readListBegin()
          for _i361 in range(_size357):
            _elem362 = iprot.readI64()
            self.records.append(_elem362)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter363 in self.keys:
        oprot.writeString(iter363)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter364 in self.records:
        oprot.writeI64(iter364)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearKeysRecords_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearKeysRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype368, _size365) = iprot.readSetBegin()
          for _i369 in range(_size365):
            _elem370 = iprot.readString()
            self.success.append(_elem370)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter371 in self.success:
        oprot.writeString(iter371)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTime_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTime_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype375, _size372) = iprot.readSetBegin()
          for _i376 in range(_size372):
            _elem377 = iprot.readString()
            self.success.append(_elem377)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter378 in self.success:
        oprot.writeString(iter378)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTimestr_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTimestr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype382, _size379) = iprot.readSetBegin()
          for _i383 in range(_size379):
            _elem384 = iprot.readString()
            self.success.append(_elem384)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter385 in self.success:
        oprot.writeString(iter385)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype389, _size386) = iprot.readListBegin()
          for _i390 in range(_size386):
            _elem391 = iprot.readI64()
            self.records.append(_elem391)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter392 in self.records:
        oprot.writeI64(iter392)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype394, _vtype395, _size393 ) = iprot.readMapBegin()
          for _i397 in range(_size393):
            _key398 = iprot.readI64()
            _val399 = []
            (_etype403, _size400) = iprot.readSetBegin()
            for _i404 in range(_size400):
              _elem405 = iprot.readString()
              _val399.append(_elem405)
            iprot.readSetEnd()
            self.success[_key398] = _val399
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter406,viter407 in list(self.success.items()):
        oprot.writeI64(kiter406)
        oprot.writeSetBegin(TType.STRING, len(viter407))
        for iter408 in viter407:
          oprot.writeString(iter408)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype412, _size409) = iprot.readListBegin()
          for _i413 in range(_size409):
            _elem414 = iprot.readI64()
            self.records.append(_elem414)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter415 in self.records:
        oprot.writeI64(iter415)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype417, _vtype418, _size416 ) = iprot.readMapBegin()
          for _i420 in range(_size416):
            _key421 = iprot.readI64()
            _val422 = []
            (_etype426, _size423) = iprot.readSetBegin()
            for _i427 in range(_size423):
              _elem428 = iprot.readString()
              _val422.append(_elem428)
            iprot.readSetEnd()
            self.success[_key421] = _val422
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter429,viter430 in list(self.success.items()):
        oprot.writeI64(kiter429)
        oprot.writeSetBegin(TType.STRING, len(viter430))
        for iter431 in viter430:
          oprot.writeString(iter431)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype435, _size432) = iprot.readListBegin()
          for _i436 in range(_size432):
            _elem437 = iprot.readI64()
            self.records.append(_elem437)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter438 in self.records:
        oprot.writeI64(iter438)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRING,None)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype440, _vtype441, _size439 ) = iprot.readMapBegin()
          for _i443 in range(_size439):
            _key444 = iprot.readI64()
            _val445 = []
            (_etype449, _size446) = iprot.readSetBegin()
            for _i450 in range(_size446):
              _elem451 = iprot.readString()
              _val445.append(_elem451)
            iprot.readSetEnd()
            self.success[_key444] = _val445
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter452,viter453 in list(self.success.items()):
        oprot.writeI64(kiter452)
        oprot.writeSetBegin(TType.STRING, len(viter453))
        for iter454 in viter453:
          oprot.writeString(iter454)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStart_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStart_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype456, _vtype457, _size455 ) = iprot.readMapBegin()
          for _i459 in range(_size455):
            _key460 = iprot.readString()
            _val461 = {}
            (_ktype463, _vtype464, _size462 ) = iprot.readMapBegin()
            for _i466 in range(_size462):
              _key467 = iprot.readI32()
              _val468 = []
              (_etype472, _size469) = iprot.readSetBegin()
              for _i473 in range(_size469):
                _elem474 = TObject()
                _elem474.read(iprot)
                _val468.append(_elem474)
              iprot.readSetEnd()
              _val461[_key467] = _val468
            iprot.readMapEnd()
            self.success[_key460] = _val461
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter475,viter476 in list(self.success.items()):
        oprot.writeString(kiter475)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter476))
        for kiter477,viter478 in list(viter476.items()):
          oprot.writeI32(kiter477)
          oprot.writeSetBegin(TType.STRUCT, len(viter478))
          for iter479 in viter478:
            iter479.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstr_args:
  """
  Attributes:
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype481, _vtype482, _size480 ) = iprot.readMapBegin()
          for _i484 in range(_size480):
            _key485 = iprot.readString()
            _val486 = {}
            (_ktype488, _vtype489, _size487 ) = iprot.readMapBegin()
            for _i491 in range(_size487):
              _key492 = iprot.readI32()
              _val493 = []
              (_etype497, _size494) = iprot.readSetBegin()
              for _i498 in range(_size494):
                _elem499 = TObject()
                _elem499.read(iprot)
                _val493.append(_elem499)
              iprot.readSetEnd()
              _val486[_key492] = _val493
            iprot.readMapEnd()
            self.success[_key485] = _val486
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter500,viter501 in list(self.success.items()):
        oprot.writeString(kiter500)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter501))
        for kiter502,viter503 in list(viter501.items()):
          oprot.writeI32(kiter502)
          oprot.writeSetBegin(TType.STRUCT, len(viter503))
          for iter504 in viter503:
            iter504.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartEnd_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartEnd_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype506, _vtype507, _size505 ) = iprot.readMapBegin()
          for _i509 in range(_size505):
            _key510 = iprot.readString()
            _val511 = {}
            (_ktype513, _vtype514, _size512 ) = iprot.readMapBegin()
            for _i516 in range(_size512):
              _key517 = iprot.readI32()
              _val518 = []
              (_etype522, _size519) = iprot.readSetBegin()
              for _i523 in range(_size519):
                _elem524 = TObject()
                _elem524.read(iprot)
                _val518.append(_elem524)
              iprot.readSetEnd()
              _val511[_key517] = _val518
            iprot.readMapEnd()
            self.success[_key510] = _val511
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter525,viter526 in list(self.success.items()):
        oprot.writeString(kiter525)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter526))
        for kiter527,viter528 in list(viter526.items()):
          oprot.writeI32(kiter527)
          oprot.writeSetBegin(TType.STRUCT, len(viter528))
          for iter529 in viter528:
            iter529.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstrEndstr_args:
  """
  Attributes:
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstrEndstr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.MAP,(TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype531, _vtype532, _size530 ) = iprot.readMapBegin()
          for _i534 in range(_size530):
            _key535 = iprot.readString()
            _val536 = {}
            (_ktype538, _vtype539, _size537 ) = iprot.readMapBegin()
            for _i541 in range(_size537):
              _key542 = iprot.readI32()
              _val543 = []
              (_etype547, _size544) = iprot.readSetBegin()
              for _i548 in range(_size544):
                _elem549 = TObject()
                _elem549.read(iprot)
                _val543.append(_elem549)
              iprot.readSetEnd()
              _val536[_key542] = _val543
            iprot.readMapEnd()
            self.success[_key535] = _val536
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.success))
      for kiter550,viter551 in list(self.success.items()):
        oprot.writeString(kiter550)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter551))
        for kiter552,viter553 in list(viter551.items()):
          oprot.writeI32(kiter552)
          oprot.writeSetBegin(TType.STRUCT, len(viter553))
          for iter554 in viter553:
            iter554.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStart_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype556, _vtype557, _size555 ) = iprot.readMapBegin()
          for _i559 in range(_size555):
            _key560 = iprot.readI32()
            _val561 = []
            (_etype565, _size562) = iprot.readSetBegin()
            for _i566 in range(_size562):
              _elem567 = TObject()
              _elem567.read(iprot)
              _val561.append(_elem567)
            iprot.readSetEnd()
            self.success[_key560] = _val561
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter568,viter569 in list(self.success.items()):
        oprot.writeI32(kiter568)
        oprot.writeSetBegin(TType.STRUCT, len(viter569))
        for iter570 in viter569:
          iter570.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype572, _vtype573, _size571 ) = iprot.readMapBegin()
          for _i575 in range(_size571):
            _key576 = iprot.readI32()
            _val577 = []
            (_etype581, _size578) = iprot.readSetBegin()
            for _i582 in range(_size578):
              _elem583 = TObject()
              _elem583.read(iprot)
              _val577.append(_elem583)
            iprot.readSetEnd()
            self.success[_key576] = _val577
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter584,viter585 in list(self.success.items()):
        oprot.writeI32(kiter584)
        oprot.writeSetBegin(TType.STRUCT, len(viter585))
        for iter586 in viter585:
          iter586.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartEnd_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'start', None, None, ), # 3
    (4, TType.I64, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 3)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 4)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype588, _vtype589, _size587 ) = iprot.readMapBegin()
          for _i591 in range(_size587):
            _key592 = iprot.readI32()
            _val593 = []
            (_etype597, _size594) = iprot.readSetBegin()
            for _i598 in range(_size594):
              _elem599 = TObject()
              _elem599.read(iprot)
              _val593.append(_elem599)
            iprot.readSetEnd()
            self.success[_key592] = _val593
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter600,viter601 in list(self.success.items()):
        oprot.writeI32(kiter600)
        oprot.writeSetBegin(TType.STRUCT, len(viter601))
        for iter602 in viter601:
          iter602.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstrEndstr_args:
  """
  Attributes:
   - key
   - record
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'start', None, None, ), # 3
    (4, TType.STRING, 'tend', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, record=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 3)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 4)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyRecordStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype604, _vtype605, _size603 ) = iprot.readMapBegin()
          for _i607 in range(_size603):
            _key608 = iprot.readI32()
            _val609 = []
            (_etype613, _size610) = iprot.readSetBegin()
            for _i614 in range(_size610):
              _elem615 = TObject()
              _elem615.read(iprot)
              _val609.append(_elem615)
            iprot.readSetEnd()
            self.success[_key608] = _val609
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyRecordStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.SET, len(self.success))
      for kiter616,viter617 in list(self.success.items()):
        oprot.writeI32(kiter616)
        oprot.writeSetBegin(TType.STRUCT, len(viter617))
        for iter618 in viter617:
          iter618.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStart_args:
  """
  Attributes:
   - key
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStart_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStart_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype620, _vtype621, _size619 ) = iprot.readMapBegin()
          for _i623 in range(_size619):
            _key624 = TObject()
            _key624.read(iprot)
            _val625 = {}
            (_ktype627, _vtype628, _size626 ) = iprot.readMapBegin()
            for _i630 in range(_size626):
              _key631 = iprot.readI32()
              _val632 = []
              (_etype636, _size633) = iprot.readSetBegin()
              for _i637 in range(_size633):
                _elem638 = iprot.readI64()
                _val632.append(_elem638)
              iprot.readSetEnd()
              _val625[_key631] = _val632
            iprot.readMapEnd()
            self.success[_key624] = _val625
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStart_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter639,viter640 in list(self.success.items()):
        kiter639.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter640))
        for kiter641,viter642 in list(viter640.items()):
          oprot.writeI32(kiter641)
          oprot.writeSetBegin(TType.I64, len(viter642))
          for iter643 in viter642:
            oprot.writeI64(iter643)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstr_args:
  """
  Attributes:
   - key
   - start
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, start=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype645, _vtype646, _size644 ) = iprot.readMapBegin()
          for _i648 in range(_size644):
            _key649 = TObject()
            _key649.read(iprot)
            _val650 = {}
            (_ktype652, _vtype653, _size651 ) = iprot.readMapBegin()
            for _i655 in range(_size651):
              _key656 = iprot.readI32()
              _val657 = []
              (_etype661, _size658) = iprot.readSetBegin()
              for _i662 in range(_size658):
                _elem663 = iprot.readI64()
                _val657.append(_elem663)
              iprot.readSetEnd()
              _val650[_key656] = _val657
            iprot.readMapEnd()
            self.success[_key649] = _val650
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter664,viter665 in list(self.success.items()):
        kiter664.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter665))
        for kiter666,viter667 in list(viter665.items()):
          oprot.writeI32(kiter666)
          oprot.writeSetBegin(TType.I64, len(viter667))
          for iter668 in viter667:
            oprot.writeI64(iter668)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartEnd_args:
  """
  Attributes:
   - key
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'start', None, None, ), # 2
    (3, TType.I64, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.start = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.tend = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartEnd_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.I64, 2)
      oprot.writeI64(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.I64, 3)
      oprot.writeI64(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartEnd_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype670, _vtype671, _size669 ) = iprot.readMapBegin()
          for _i673 in range(_size669):
            _key674 = TObject()
            _key674.read(iprot)
            _val675 = {}
            (_ktype677, _vtype678, _size676 ) = iprot.readMapBegin()
            for _i680 in range(_size676):
              _key681 = iprot.readI32()
              _val682 = []
              (_etype686, _size683) = iprot.readSetBegin()
              for _i687 in range(_size683):
                _elem688 = iprot.readI64()
                _val682.append(_elem688)
              iprot.readSetEnd()
              _val675[_key681] = _val682
            iprot.readMapEnd()
            self.success[_key674] = _val675
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartEnd_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter689,viter690 in list(self.success.items()):
        kiter689.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter690))
        for kiter691,viter692 in list(viter690.items()):
          oprot.writeI32(kiter691)
          oprot.writeSetBegin(TType.I64, len(viter692))
          for iter693 in viter692:
            oprot.writeI64(iter693)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstrEndstr_args:
  """
  Attributes:
   - key
   - start
   - tend
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'start', None, None, ), # 2
    (3, TType.STRING, 'tend', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, start=None, tend=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.start = start
    self.tend = tend
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstrEndstr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.start is not None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.tend is not None:
      oprot.writeFieldBegin('tend', TType.STRING, 3)
      oprot.writeString(self.tend)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.start)
    value = (value * 31) ^ hash(self.tend)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diffKeyStartstrEndstr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec),TType.MAP,(TType.I32,None,TType.SET,(TType.I64,None))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype695, _vtype696, _size694 ) = iprot.readMapBegin()
          for _i698 in range(_size694):
            _key699 = TObject()
            _key699.read(iprot)
            _val700 = {}
            (_ktype702, _vtype703, _size701 ) = iprot.readMapBegin()
            for _i705 in range(_size701):
              _key706 = iprot.readI32()
              _val707 = []
              (_etype711, _size708) = iprot.readSetBegin()
              for _i712 in range(_size708):
                _elem713 = iprot.readI64()
                _val707.append(_elem713)
              iprot.readSetEnd()
              _val700[_key706] = _val707
            iprot.readMapEnd()
            self.success[_key699] = _val700
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diffKeyStartstrEndstr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.success))
      for kiter714,viter715 in list(self.success.items()):
        kiter714.write(oprot)
        oprot.writeMapBegin(TType.I32, TType.SET, len(viter715))
        for kiter716,viter717 in list(viter715.items()):
          oprot.writeI32(kiter716)
          oprot.writeSetBegin(TType.I64, len(viter717))
          for iter718 in viter717:
            oprot.writeI64(iter718)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invokePlugin_args:
  """
  Attributes:
   - id
   - method
   - params
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'method', None, None, ), # 2
    (3, TType.LIST, 'params', (TType.STRUCT,(concourse.thriftapi.complex.ttypes.ComplexTObject, concourse.thriftapi.complex.ttypes.ComplexTObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, id=None, method=None, params=None, creds=None, transaction=None, environment=None,):
    self.id = id
    self.method = method
    self.params = params
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.method = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.params = []
          (_etype722, _size719) = iprot.readListBegin()
          for _i723 in range(_size719):
            _elem724 = concourse.thriftapi.complex.ttypes.ComplexTObject()
            _elem724.read(iprot)
            self.params.append(_elem724)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invokePlugin_args')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.method is not None:
      oprot.writeFieldBegin('method', TType.STRING, 2)
      oprot.writeString(self.method)
      oprot.writeFieldEnd()
    if self.params is not None:
      oprot.writeFieldBegin('params', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.params))
      for iter725 in self.params:
        iter725.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.method)
    value = (value * 31) ^ hash(self.params)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class invokePlugin_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (concourse.thriftapi.complex.ttypes.ComplexTObject, concourse.thriftapi.complex.ttypes.ComplexTObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = concourse.thriftapi.complex.ttypes.ComplexTObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('invokePlugin_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_args:
  """
  Attributes:
   - username
   - password
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'username', None, None, ), # 1
    (2, TType.STRING, 'password', None, None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, username=None, password=None, environment=None,):
    self.username = username
    self.password = password
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_args')
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.username)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class login_result:
  """
  Attributes:
   - success
   - ex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AccessToken, AccessToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ex=None,):
    self.success = success
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AccessToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('login_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logout_args:
  """
  Attributes:
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
  )

  def __init__(self, token=None, environment=None,):
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logout_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class logout_result:
  """
  Attributes:
   - ex
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, ex=None,):
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('logout_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stage_args:
  """
  Attributes:
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'environment', None, None, ), # 2
  )

  def __init__(self, token=None, environment=None,):
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = AccessToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stage_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 2)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stage_result:
  """
  Attributes:
   - success
   - ex
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TransactionToken, TransactionToken.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ex=None,):
    self.success = success
    self.ex = ex

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TransactionToken()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stage_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJson_args:
  """
  Attributes:
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, json=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJson_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype729, _size726) = iprot.readSetBegin()
          for _i730 in range(_size726):
            _elem731 = iprot.readI64()
            self.success.append(_elem731)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter732 in self.success:
        oprot.writeI64(iter732)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecord_args:
  """
  Attributes:
   - json
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, json=None, record=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecord_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecords_args:
  """
  Attributes:
   - json
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'json', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, json=None, records=None, creds=None, transaction=None, environment=None,):
    self.json = json
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype736, _size733) = iprot.readListBegin()
          for _i737 in range(_size733):
            _elem738 = iprot.readI64()
            self.records.append(_elem738)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecords_args')
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 1)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter739 in self.records:
        oprot.writeI64(iter739)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insertJsonRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype741, _vtype742, _size740 ) = iprot.readMapBegin()
          for _i744 in range(_size740):
            _key745 = iprot.readI64()
            _val746 = iprot.readBool()
            self.success[_key745] = _val746
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insertJsonRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter747,viter748 in list(self.success.items()):
        oprot.writeI64(kiter747)
        oprot.writeBool(viter748)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype752, _size749) = iprot.readListBegin()
          for _i753 in range(_size749):
            _elem754 = iprot.readI64()
            self.records.append(_elem754)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter755 in self.records:
        oprot.writeI64(iter755)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeKeyValueRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype757, _vtype758, _size756 ) = iprot.readMapBegin()
          for _i760 in range(_size756):
            _key761 = iprot.readI64()
            _val762 = iprot.readBool()
            self.success[_key761] = _val762
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeKeyValueRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter763,viter764 in list(self.success.items()):
        oprot.writeI64(kiter763)
        oprot.writeBool(viter764)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecord_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecord_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecords_args:
  """
  Attributes:
   - key
   - value
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.LIST, 'records', (TType.I64,None), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype768, _size765) = iprot.readListBegin()
          for _i769 in range(_size765):
            _elem770 = iprot.readI64()
            self.records.append(_elem770)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter771 in self.records:
        oprot.writeI64(iter771)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setKeyValueRecords_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setKeyValueRecords_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reconcileKeyRecordValues_args:
  """
  Attributes:
   - key
   - record
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.SET, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.values = []
          (_etype775, _size772) = iprot.readSetBegin()
          for _i776 in range(_size772):
            _elem777 = TObject()
            _elem777.read(iprot)
            self.values.append(_elem777)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reconcileKeyRecordValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.values))
      for iter778 in self.values:
        iter778.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class reconcileKeyRecordValues_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('reconcileKeyRecordValues_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inventory_args:
  """
  Attributes:
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, transaction=None, environment=None,):
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inventory_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 2)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class inventory_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype782, _size779) = iprot.readSetBegin()
          for _i783 in range(_size779):
            _elem784 = iprot.readI64()
            self.success.append(_elem784)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('inventory_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter785 in self.success:
        oprot.writeI64(iter785)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype787, _vtype788, _size786 ) = iprot.readMapBegin()
          for _i790 in range(_size786):
            _key791 = iprot.readString()
            _val792 = []
            (_etype796, _size793) = iprot.readSetBegin()
            for _i797 in range(_size793):
              _elem798 = TObject()
              _elem798.read(iprot)
              _val792.append(_elem798)
            iprot.readSetEnd()
            self.success[_key791] = _val792
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter799,viter800 in list(self.success.items()):
        oprot.writeString(kiter799)
        oprot.writeSetBegin(TType.STRUCT, len(viter800))
        for iter801 in viter800:
          iter801.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype805, _size802) = iprot.readListBegin()
          for _i806 in range(_size802):
            _elem807 = iprot.readI64()
            self.records.append(_elem807)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter808 in self.records:
        oprot.writeI64(iter808)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype810, _vtype811, _size809 ) = iprot.readMapBegin()
          for _i813 in range(_size809):
            _key814 = iprot.readI64()
            _val815 = {}
            (_ktype817, _vtype818, _size816 ) = iprot.readMapBegin()
            for _i820 in range(_size816):
              _key821 = iprot.readString()
              _val822 = []
              (_etype826, _size823) = iprot.readSetBegin()
              for _i827 in range(_size823):
                _elem828 = TObject()
                _elem828.read(iprot)
                _val822.append(_elem828)
              iprot.readSetEnd()
              _val815[_key821] = _val822
            iprot.readMapEnd()
            self.success[_key814] = _val815
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter829,viter830 in list(self.success.items()):
        oprot.writeI64(kiter829)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter830))
        for kiter831,viter832 in list(viter830.items()):
          oprot.writeString(kiter831)
          oprot.writeSetBegin(TType.STRUCT, len(viter832))
          for iter833 in viter832:
            iter833.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTime_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTime_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype835, _vtype836, _size834 ) = iprot.readMapBegin()
          for _i838 in range(_size834):
            _key839 = iprot.readString()
            _val840 = []
            (_etype844, _size841) = iprot.readSetBegin()
            for _i845 in range(_size841):
              _elem846 = TObject()
              _elem846.read(iprot)
              _val840.append(_elem846)
            iprot.readSetEnd()
            self.success[_key839] = _val840
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter847,viter848 in list(self.success.items()):
        oprot.writeString(kiter847)
        oprot.writeSetBegin(TType.STRUCT, len(viter848))
        for iter849 in viter848:
          iter849.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTimestr_args:
  """
  Attributes:
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTimestr_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype851, _vtype852, _size850 ) = iprot.readMapBegin()
          for _i854 in range(_size850):
            _key855 = iprot.readString()
            _val856 = []
            (_etype860, _size857) = iprot.readSetBegin()
            for _i861 in range(_size857):
              _elem862 = TObject()
              _elem862.read(iprot)
              _val856.append(_elem862)
            iprot.readSetEnd()
            self.success[_key855] = _val856
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter863,viter864 in list(self.success.items()):
        oprot.writeString(kiter863)
        oprot.writeSetBegin(TType.STRUCT, len(viter864))
        for iter865 in viter864:
          iter865.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype869, _size866) = iprot.readListBegin()
          for _i870 in range(_size866):
            _elem871 = iprot.readI64()
            self.records.append(_elem871)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter872 in self.records:
        oprot.writeI64(iter872)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype874, _vtype875, _size873 ) = iprot.readMapBegin()
          for _i877 in range(_size873):
            _key878 = iprot.readI64()
            _val879 = {}
            (_ktype881, _vtype882, _size880 ) = iprot.readMapBegin()
            for _i884 in range(_size880):
              _key885 = iprot.readString()
              _val886 = []
              (_etype890, _size887) = iprot.readSetBegin()
              for _i891 in range(_size887):
                _elem892 = TObject()
                _elem892.read(iprot)
                _val886.append(_elem892)
              iprot.readSetEnd()
              _val879[_key885] = _val886
            iprot.readMapEnd()
            self.success[_key878] = _val879
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter893,viter894 in list(self.success.items()):
        oprot.writeI64(kiter893)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter894))
        for kiter895,viter896 in list(viter894.items()):
          oprot.writeString(kiter895)
          oprot.writeSetBegin(TType.STRUCT, len(viter896))
          for iter897 in viter896:
            iter897.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype901, _size898) = iprot.readListBegin()
          for _i902 in range(_size898):
            _elem903 = iprot.readI64()
            self.records.append(_elem903)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter904 in self.records:
        oprot.writeI64(iter904)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype906, _vtype907, _size905 ) = iprot.readMapBegin()
          for _i909 in range(_size905):
            _key910 = iprot.readI64()
            _val911 = {}
            (_ktype913, _vtype914, _size912 ) = iprot.readMapBegin()
            for _i916 in range(_size912):
              _key917 = iprot.readString()
              _val918 = []
              (_etype922, _size919) = iprot.readSetBegin()
              for _i923 in range(_size919):
                _elem924 = TObject()
                _elem924.read(iprot)
                _val918.append(_elem924)
              iprot.readSetEnd()
              _val911[_key917] = _val918
            iprot.readMapEnd()
            self.success[_key910] = _val911
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter925,viter926 in list(self.success.items()):
        oprot.writeI64(kiter925)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter926))
        for kiter927,viter928 in list(viter926.items()):
          oprot.writeString(kiter927)
          oprot.writeSetBegin(TType.STRUCT, len(viter928))
          for iter929 in viter928:
            iter929.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype933, _size930) = iprot.readSetBegin()
          for _i934 in range(_size930):
            _elem935 = TObject()
            _elem935.read(iprot)
            self.success.append(_elem935)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter936 in self.success:
        iter936.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype940, _size937) = iprot.readSetBegin()
          for _i941 in range(_size937):
            _elem942 = TObject()
            _elem942.read(iprot)
            self.success.append(_elem942)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter943 in self.success:
        iter943.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype947, _size944) = iprot.readSetBegin()
          for _i948 in range(_size944):
            _elem949 = TObject()
            _elem949.read(iprot)
            self.success.append(_elem949)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRUCT, len(self.success))
      for iter950 in self.success:
        iter950.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype954, _size951) = iprot.readListBegin()
          for _i955 in range(_size951):
            _elem956 = iprot.readString()
            self.keys.append(_elem956)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter957 in self.keys:
        oprot.writeString(iter957)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype959, _vtype960, _size958 ) = iprot.readMapBegin()
          for _i962 in range(_size958):
            _key963 = iprot.readString()
            _val964 = []
            (_etype968, _size965) = iprot.readSetBegin()
            for _i969 in range(_size965):
              _elem970 = TObject()
              _elem970.read(iprot)
              _val964.append(_elem970)
            iprot.readSetEnd()
            self.success[_key963] = _val964
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter971,viter972 in list(self.success.items()):
        oprot.writeString(kiter971)
        oprot.writeSetBegin(TType.STRUCT, len(viter972))
        for iter973 in viter972:
          iter973.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype977, _size974) = iprot.readListBegin()
          for _i978 in range(_size974):
            _elem979 = iprot.readString()
            self.keys.append(_elem979)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter980 in self.keys:
        oprot.writeString(iter980)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype982, _vtype983, _size981 ) = iprot.readMapBegin()
          for _i985 in range(_size981):
            _key986 = iprot.readString()
            _val987 = []
            (_etype991, _size988) = iprot.readSetBegin()
            for _i992 in range(_size988):
              _elem993 = TObject()
              _elem993.read(iprot)
              _val987.append(_elem993)
            iprot.readSetEnd()
            self.success[_key986] = _val987
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter994,viter995 in list(self.success.items()):
        oprot.writeString(kiter994)
        oprot.writeSetBegin(TType.STRUCT, len(viter995))
        for iter996 in viter995:
          iter996.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1000, _size997) = iprot.readListBegin()
          for _i1001 in range(_size997):
            _elem1002 = iprot.readString()
            self.keys.append(_elem1002)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1003 in self.keys:
        oprot.writeString(iter1003)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1005, _vtype1006, _size1004 ) = iprot.readMapBegin()
          for _i1008 in range(_size1004):
            _key1009 = iprot.readString()
            _val1010 = []
            (_etype1014, _size1011) = iprot.readSetBegin()
            for _i1015 in range(_size1011):
              _elem1016 = TObject()
              _elem1016.read(iprot)
              _val1010.append(_elem1016)
            iprot.readSetEnd()
            self.success[_key1009] = _val1010
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
      for kiter1017,viter1018 in list(self.success.items()):
        oprot.writeString(kiter1017)
        oprot.writeSetBegin(TType.STRUCT, len(viter1018))
        for iter1019 in viter1018:
          iter1019.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1023, _size1020) = iprot.readListBegin()
          for _i1024 in range(_size1020):
            _elem1025 = iprot.readString()
            self.keys.append(_elem1025)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1029, _size1026) = iprot.readListBegin()
          for _i1030 in range(_size1026):
            _elem1031 = iprot.readI64()
            self.records.append(_elem1031)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1032 in self.keys:
        oprot.writeString(iter1032)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1033 in self.records:
        oprot.writeI64(iter1033)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1035, _vtype1036, _size1034 ) = iprot.readMapBegin()
          for _i1038 in range(_size1034):
            _key1039 = iprot.readI64()
            _val1040 = {}
            (_ktype1042, _vtype1043, _size1041 ) = iprot.readMapBegin()
            for _i1045 in range(_size1041):
              _key1046 = iprot.readString()
              _val1047 = []
              (_etype1051, _size1048) = iprot.readSetBegin()
              for _i1052 in range(_size1048):
                _elem1053 = TObject()
                _elem1053.read(iprot)
                _val1047.append(_elem1053)
              iprot.readSetEnd()
              _val1040[_key1046] = _val1047
            iprot.readMapEnd()
            self.success[_key1039] = _val1040
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1054,viter1055 in list(self.success.items()):
        oprot.writeI64(kiter1054)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1055))
        for kiter1056,viter1057 in list(viter1055.items()):
          oprot.writeString(kiter1056)
          oprot.writeSetBegin(TType.STRUCT, len(viter1057))
          for iter1058 in viter1057:
            iter1058.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1062, _size1059) = iprot.readListBegin()
          for _i1063 in range(_size1059):
            _elem1064 = iprot.readI64()
            self.records.append(_elem1064)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1065 in self.records:
        oprot.writeI64(iter1065)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1067, _vtype1068, _size1066 ) = iprot.readMapBegin()
          for _i1070 in range(_size1066):
            _key1071 = iprot.readI64()
            _val1072 = []
            (_etype1076, _size1073) = iprot.readSetBegin()
            for _i1077 in range(_size1073):
              _elem1078 = TObject()
              _elem1078.read(iprot)
              _val1072.append(_elem1078)
            iprot.readSetEnd()
            self.success[_key1071] = _val1072
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1079,viter1080 in list(self.success.items()):
        oprot.writeI64(kiter1079)
        oprot.writeSetBegin(TType.STRUCT, len(viter1080))
        for iter1081 in viter1080:
          iter1081.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1085, _size1082) = iprot.readListBegin()
          for _i1086 in range(_size1082):
            _elem1087 = iprot.readI64()
            self.records.append(_elem1087)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1088 in self.records:
        oprot.writeI64(iter1088)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1090, _vtype1091, _size1089 ) = iprot.readMapBegin()
          for _i1093 in range(_size1089):
            _key1094 = iprot.readI64()
            _val1095 = []
            (_etype1099, _size1096) = iprot.readSetBegin()
            for _i1100 in range(_size1096):
              _elem1101 = TObject()
              _elem1101.read(iprot)
              _val1095.append(_elem1101)
            iprot.readSetEnd()
            self.success[_key1094] = _val1095
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1102,viter1103 in list(self.success.items()):
        oprot.writeI64(kiter1102)
        oprot.writeSetBegin(TType.STRUCT, len(viter1103))
        for iter1104 in viter1103:
          iter1104.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1108, _size1105) = iprot.readListBegin()
          for _i1109 in range(_size1105):
            _elem1110 = iprot.readI64()
            self.records.append(_elem1110)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1111 in self.records:
        oprot.writeI64(iter1111)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1113, _vtype1114, _size1112 ) = iprot.readMapBegin()
          for _i1116 in range(_size1112):
            _key1117 = iprot.readI64()
            _val1118 = []
            (_etype1122, _size1119) = iprot.readSetBegin()
            for _i1123 in range(_size1119):
              _elem1124 = TObject()
              _elem1124.read(iprot)
              _val1118.append(_elem1124)
            iprot.readSetEnd()
            self.success[_key1117] = _val1118
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1125,viter1126 in list(self.success.items()):
        oprot.writeI64(kiter1125)
        oprot.writeSetBegin(TType.STRUCT, len(viter1126))
        for iter1127 in viter1126:
          iter1127.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1131, _size1128) = iprot.readListBegin()
          for _i1132 in range(_size1128):
            _elem1133 = iprot.readString()
            self.keys.append(_elem1133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1137, _size1134) = iprot.readListBegin()
          for _i1138 in range(_size1134):
            _elem1139 = iprot.readI64()
            self.records.append(_elem1139)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1140 in self.keys:
        oprot.writeString(iter1140)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1141 in self.records:
        oprot.writeI64(iter1141)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1143, _vtype1144, _size1142 ) = iprot.readMapBegin()
          for _i1146 in range(_size1142):
            _key1147 = iprot.readI64()
            _val1148 = {}
            (_ktype1150, _vtype1151, _size1149 ) = iprot.readMapBegin()
            for _i1153 in range(_size1149):
              _key1154 = iprot.readString()
              _val1155 = []
              (_etype1159, _size1156) = iprot.readSetBegin()
              for _i1160 in range(_size1156):
                _elem1161 = TObject()
                _elem1161.read(iprot)
                _val1155.append(_elem1161)
              iprot.readSetEnd()
              _val1148[_key1154] = _val1155
            iprot.readMapEnd()
            self.success[_key1147] = _val1148
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1162,viter1163 in list(self.success.items()):
        oprot.writeI64(kiter1162)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1163))
        for kiter1164,viter1165 in list(viter1163.items()):
          oprot.writeString(kiter1164)
          oprot.writeSetBegin(TType.STRUCT, len(viter1165))
          for iter1166 in viter1165:
            iter1166.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1170, _size1167) = iprot.readListBegin()
          for _i1171 in range(_size1167):
            _elem1172 = iprot.readString()
            self.keys.append(_elem1172)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1176, _size1173) = iprot.readListBegin()
          for _i1177 in range(_size1173):
            _elem1178 = iprot.readI64()
            self.records.append(_elem1178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1179 in self.keys:
        oprot.writeString(iter1179)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1180 in self.records:
        oprot.writeI64(iter1180)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1182, _vtype1183, _size1181 ) = iprot.readMapBegin()
          for _i1185 in range(_size1181):
            _key1186 = iprot.readI64()
            _val1187 = {}
            (_ktype1189, _vtype1190, _size1188 ) = iprot.readMapBegin()
            for _i1192 in range(_size1188):
              _key1193 = iprot.readString()
              _val1194 = []
              (_etype1198, _size1195) = iprot.readSetBegin()
              for _i1199 in range(_size1195):
                _elem1200 = TObject()
                _elem1200.read(iprot)
                _val1194.append(_elem1200)
              iprot.readSetEnd()
              _val1187[_key1193] = _val1194
            iprot.readMapEnd()
            self.success[_key1186] = _val1187
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1201,viter1202 in list(self.success.items()):
        oprot.writeI64(kiter1201)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1202))
        for kiter1203,viter1204 in list(viter1202.items()):
          oprot.writeString(kiter1203)
          oprot.writeSetBegin(TType.STRUCT, len(viter1204))
          for iter1205 in viter1204:
            iter1205.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1207, _vtype1208, _size1206 ) = iprot.readMapBegin()
          for _i1210 in range(_size1206):
            _key1211 = iprot.readI64()
            _val1212 = {}
            (_ktype1214, _vtype1215, _size1213 ) = iprot.readMapBegin()
            for _i1217 in range(_size1213):
              _key1218 = iprot.readString()
              _val1219 = []
              (_etype1223, _size1220) = iprot.readSetBegin()
              for _i1224 in range(_size1220):
                _elem1225 = TObject()
                _elem1225.read(iprot)
                _val1219.append(_elem1225)
              iprot.readSetEnd()
              _val1212[_key1218] = _val1219
            iprot.readMapEnd()
            self.success[_key1211] = _val1212
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1226,viter1227 in list(self.success.items()):
        oprot.writeI64(kiter1226)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1227))
        for kiter1228,viter1229 in list(viter1227.items()):
          oprot.writeString(kiter1228)
          oprot.writeSetBegin(TType.STRUCT, len(viter1229))
          for iter1230 in viter1229:
            iter1230.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1232, _vtype1233, _size1231 ) = iprot.readMapBegin()
          for _i1235 in range(_size1231):
            _key1236 = iprot.readI64()
            _val1237 = {}
            (_ktype1239, _vtype1240, _size1238 ) = iprot.readMapBegin()
            for _i1242 in range(_size1238):
              _key1243 = iprot.readString()
              _val1244 = []
              (_etype1248, _size1245) = iprot.readSetBegin()
              for _i1249 in range(_size1245):
                _elem1250 = TObject()
                _elem1250.read(iprot)
                _val1244.append(_elem1250)
              iprot.readSetEnd()
              _val1237[_key1243] = _val1244
            iprot.readMapEnd()
            self.success[_key1236] = _val1237
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1251,viter1252 in list(self.success.items()):
        oprot.writeI64(kiter1251)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1252))
        for kiter1253,viter1254 in list(viter1252.items()):
          oprot.writeString(kiter1253)
          oprot.writeSetBegin(TType.STRUCT, len(viter1254))
          for iter1255 in viter1254:
            iter1255.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTime_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTime_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1257, _vtype1258, _size1256 ) = iprot.readMapBegin()
          for _i1260 in range(_size1256):
            _key1261 = iprot.readI64()
            _val1262 = {}
            (_ktype1264, _vtype1265, _size1263 ) = iprot.readMapBegin()
            for _i1267 in range(_size1263):
              _key1268 = iprot.readString()
              _val1269 = []
              (_etype1273, _size1270) = iprot.readSetBegin()
              for _i1274 in range(_size1270):
                _elem1275 = TObject()
                _elem1275.read(iprot)
                _val1269.append(_elem1275)
              iprot.readSetEnd()
              _val1262[_key1268] = _val1269
            iprot.readMapEnd()
            self.success[_key1261] = _val1262
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1276,viter1277 in list(self.success.items()):
        oprot.writeI64(kiter1276)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1277))
        for kiter1278,viter1279 in list(viter1277.items()):
          oprot.writeString(kiter1278)
          oprot.writeSetBegin(TType.STRUCT, len(viter1279))
          for iter1280 in viter1279:
            iter1280.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTimestr_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTimestr_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1282, _vtype1283, _size1281 ) = iprot.readMapBegin()
          for _i1285 in range(_size1281):
            _key1286 = iprot.readI64()
            _val1287 = {}
            (_ktype1289, _vtype1290, _size1288 ) = iprot.readMapBegin()
            for _i1292 in range(_size1288):
              _key1293 = iprot.readString()
              _val1294 = []
              (_etype1298, _size1295) = iprot.readSetBegin()
              for _i1299 in range(_size1295):
                _elem1300 = TObject()
                _elem1300.read(iprot)
                _val1294.append(_elem1300)
              iprot.readSetEnd()
              _val1287[_key1293] = _val1294
            iprot.readMapEnd()
            self.success[_key1286] = _val1287
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1301,viter1302 in list(self.success.items()):
        oprot.writeI64(kiter1301)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1302))
        for kiter1303,viter1304 in list(viter1302.items()):
          oprot.writeString(kiter1303)
          oprot.writeSetBegin(TType.STRUCT, len(viter1304))
          for iter1305 in viter1304:
            iter1305.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTime_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTime_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1307, _vtype1308, _size1306 ) = iprot.readMapBegin()
          for _i1310 in range(_size1306):
            _key1311 = iprot.readI64()
            _val1312 = {}
            (_ktype1314, _vtype1315, _size1313 ) = iprot.readMapBegin()
            for _i1317 in range(_size1313):
              _key1318 = iprot.readString()
              _val1319 = []
              (_etype1323, _size1320) = iprot.readSetBegin()
              for _i1324 in range(_size1320):
                _elem1325 = TObject()
                _elem1325.read(iprot)
                _val1319.append(_elem1325)
              iprot.readSetEnd()
              _val1312[_key1318] = _val1319
            iprot.readMapEnd()
            self.success[_key1311] = _val1312
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1326,viter1327 in list(self.success.items()):
        oprot.writeI64(kiter1326)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1327))
        for kiter1328,viter1329 in list(viter1327.items()):
          oprot.writeString(kiter1328)
          oprot.writeSetBegin(TType.STRUCT, len(viter1329))
          for iter1330 in viter1329:
            iter1330.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTimestr_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTimestr_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1332, _vtype1333, _size1331 ) = iprot.readMapBegin()
          for _i1335 in range(_size1331):
            _key1336 = iprot.readI64()
            _val1337 = {}
            (_ktype1339, _vtype1340, _size1338 ) = iprot.readMapBegin()
            for _i1342 in range(_size1338):
              _key1343 = iprot.readString()
              _val1344 = []
              (_etype1348, _size1345) = iprot.readSetBegin()
              for _i1349 in range(_size1345):
                _elem1350 = TObject()
                _elem1350.read(iprot)
                _val1344.append(_elem1350)
              iprot.readSetEnd()
              _val1337[_key1343] = _val1344
            iprot.readMapEnd()
            self.success[_key1336] = _val1337
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1351,viter1352 in list(self.success.items()):
        oprot.writeI64(kiter1351)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1352))
        for kiter1353,viter1354 in list(viter1352.items()):
          oprot.writeString(kiter1353)
          oprot.writeSetBegin(TType.STRUCT, len(viter1354))
          for iter1355 in viter1354:
            iter1355.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1357, _vtype1358, _size1356 ) = iprot.readMapBegin()
          for _i1360 in range(_size1356):
            _key1361 = iprot.readI64()
            _val1362 = []
            (_etype1366, _size1363) = iprot.readSetBegin()
            for _i1367 in range(_size1363):
              _elem1368 = TObject()
              _elem1368.read(iprot)
              _val1362.append(_elem1368)
            iprot.readSetEnd()
            self.success[_key1361] = _val1362
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1369,viter1370 in list(self.success.items()):
        oprot.writeI64(kiter1369)
        oprot.writeSetBegin(TType.STRUCT, len(viter1370))
        for iter1371 in viter1370:
          iter1371.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1373, _vtype1374, _size1372 ) = iprot.readMapBegin()
          for _i1376 in range(_size1372):
            _key1377 = iprot.readI64()
            _val1378 = []
            (_etype1382, _size1379) = iprot.readSetBegin()
            for _i1383 in range(_size1379):
              _elem1384 = TObject()
              _elem1384.read(iprot)
              _val1378.append(_elem1384)
            iprot.readSetEnd()
            self.success[_key1377] = _val1378
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1385,viter1386 in list(self.success.items()):
        oprot.writeI64(kiter1385)
        oprot.writeSetBegin(TType.STRUCT, len(viter1386))
        for iter1387 in viter1386:
          iter1387.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1389, _vtype1390, _size1388 ) = iprot.readMapBegin()
          for _i1392 in range(_size1388):
            _key1393 = iprot.readI64()
            _val1394 = []
            (_etype1398, _size1395) = iprot.readSetBegin()
            for _i1399 in range(_size1395):
              _elem1400 = TObject()
              _elem1400.read(iprot)
              _val1394.append(_elem1400)
            iprot.readSetEnd()
            self.success[_key1393] = _val1394
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1401,viter1402 in list(self.success.items()):
        oprot.writeI64(kiter1401)
        oprot.writeSetBegin(TType.STRUCT, len(viter1402))
        for iter1403 in viter1402:
          iter1403.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1405, _vtype1406, _size1404 ) = iprot.readMapBegin()
          for _i1408 in range(_size1404):
            _key1409 = iprot.readI64()
            _val1410 = []
            (_etype1414, _size1411) = iprot.readSetBegin()
            for _i1415 in range(_size1411):
              _elem1416 = TObject()
              _elem1416.read(iprot)
              _val1410.append(_elem1416)
            iprot.readSetEnd()
            self.success[_key1409] = _val1410
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1417,viter1418 in list(self.success.items()):
        oprot.writeI64(kiter1417)
        oprot.writeSetBegin(TType.STRUCT, len(viter1418))
        for iter1419 in viter1418:
          iter1419.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1421, _vtype1422, _size1420 ) = iprot.readMapBegin()
          for _i1424 in range(_size1420):
            _key1425 = iprot.readI64()
            _val1426 = []
            (_etype1430, _size1427) = iprot.readSetBegin()
            for _i1431 in range(_size1427):
              _elem1432 = TObject()
              _elem1432.read(iprot)
              _val1426.append(_elem1432)
            iprot.readSetEnd()
            self.success[_key1425] = _val1426
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1433,viter1434 in list(self.success.items()):
        oprot.writeI64(kiter1433)
        oprot.writeSetBegin(TType.STRUCT, len(viter1434))
        for iter1435 in viter1434:
          iter1435.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1437, _vtype1438, _size1436 ) = iprot.readMapBegin()
          for _i1440 in range(_size1436):
            _key1441 = iprot.readI64()
            _val1442 = []
            (_etype1446, _size1443) = iprot.readSetBegin()
            for _i1447 in range(_size1443):
              _elem1448 = TObject()
              _elem1448.read(iprot)
              _val1442.append(_elem1448)
            iprot.readSetEnd()
            self.success[_key1441] = _val1442
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.success))
      for kiter1449,viter1450 in list(self.success.items()):
        oprot.writeI64(kiter1449)
        oprot.writeSetBegin(TType.STRUCT, len(viter1450))
        for iter1451 in viter1450:
          iter1451.write(oprot)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1455, _size1452) = iprot.readListBegin()
          for _i1456 in range(_size1452):
            _elem1457 = iprot.readString()
            self.keys.append(_elem1457)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1458 in self.keys:
        oprot.writeString(iter1458)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1460, _vtype1461, _size1459 ) = iprot.readMapBegin()
          for _i1463 in range(_size1459):
            _key1464 = iprot.readI64()
            _val1465 = {}
            (_ktype1467, _vtype1468, _size1466 ) = iprot.readMapBegin()
            for _i1470 in range(_size1466):
              _key1471 = iprot.readString()
              _val1472 = []
              (_etype1476, _size1473) = iprot.readSetBegin()
              for _i1477 in range(_size1473):
                _elem1478 = TObject()
                _elem1478.read(iprot)
                _val1472.append(_elem1478)
              iprot.readSetEnd()
              _val1465[_key1471] = _val1472
            iprot.readMapEnd()
            self.success[_key1464] = _val1465
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1479,viter1480 in list(self.success.items()):
        oprot.writeI64(kiter1479)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1480))
        for kiter1481,viter1482 in list(viter1480.items()):
          oprot.writeString(kiter1481)
          oprot.writeSetBegin(TType.STRUCT, len(viter1482))
          for iter1483 in viter1482:
            iter1483.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1487, _size1484) = iprot.readListBegin()
          for _i1488 in range(_size1484):
            _elem1489 = iprot.readString()
            self.keys.append(_elem1489)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1490 in self.keys:
        oprot.writeString(iter1490)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1492, _vtype1493, _size1491 ) = iprot.readMapBegin()
          for _i1495 in range(_size1491):
            _key1496 = iprot.readI64()
            _val1497 = {}
            (_ktype1499, _vtype1500, _size1498 ) = iprot.readMapBegin()
            for _i1502 in range(_size1498):
              _key1503 = iprot.readString()
              _val1504 = []
              (_etype1508, _size1505) = iprot.readSetBegin()
              for _i1509 in range(_size1505):
                _elem1510 = TObject()
                _elem1510.read(iprot)
                _val1504.append(_elem1510)
              iprot.readSetEnd()
              _val1497[_key1503] = _val1504
            iprot.readMapEnd()
            self.success[_key1496] = _val1497
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1511,viter1512 in list(self.success.items()):
        oprot.writeI64(kiter1511)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1512))
        for kiter1513,viter1514 in list(viter1512.items()):
          oprot.writeString(kiter1513)
          oprot.writeSetBegin(TType.STRUCT, len(viter1514))
          for iter1515 in viter1514:
            iter1515.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1519, _size1516) = iprot.readListBegin()
          for _i1520 in range(_size1516):
            _elem1521 = iprot.readString()
            self.keys.append(_elem1521)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1522 in self.keys:
        oprot.writeString(iter1522)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1524, _vtype1525, _size1523 ) = iprot.readMapBegin()
          for _i1527 in range(_size1523):
            _key1528 = iprot.readI64()
            _val1529 = {}
            (_ktype1531, _vtype1532, _size1530 ) = iprot.readMapBegin()
            for _i1534 in range(_size1530):
              _key1535 = iprot.readString()
              _val1536 = []
              (_etype1540, _size1537) = iprot.readSetBegin()
              for _i1541 in range(_size1537):
                _elem1542 = TObject()
                _elem1542.read(iprot)
                _val1536.append(_elem1542)
              iprot.readSetEnd()
              _val1529[_key1535] = _val1536
            iprot.readMapEnd()
            self.success[_key1528] = _val1529
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1543,viter1544 in list(self.success.items()):
        oprot.writeI64(kiter1543)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1544))
        for kiter1545,viter1546 in list(viter1544.items()):
          oprot.writeString(kiter1545)
          oprot.writeSetBegin(TType.STRUCT, len(viter1546))
          for iter1547 in viter1546:
            iter1547.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1551, _size1548) = iprot.readListBegin()
          for _i1552 in range(_size1548):
            _elem1553 = iprot.readString()
            self.keys.append(_elem1553)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1554 in self.keys:
        oprot.writeString(iter1554)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1556, _vtype1557, _size1555 ) = iprot.readMapBegin()
          for _i1559 in range(_size1555):
            _key1560 = iprot.readI64()
            _val1561 = {}
            (_ktype1563, _vtype1564, _size1562 ) = iprot.readMapBegin()
            for _i1566 in range(_size1562):
              _key1567 = iprot.readString()
              _val1568 = []
              (_etype1572, _size1569) = iprot.readSetBegin()
              for _i1573 in range(_size1569):
                _elem1574 = TObject()
                _elem1574.read(iprot)
                _val1568.append(_elem1574)
              iprot.readSetEnd()
              _val1561[_key1567] = _val1568
            iprot.readMapEnd()
            self.success[_key1560] = _val1561
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1575,viter1576 in list(self.success.items()):
        oprot.writeI64(kiter1575)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1576))
        for kiter1577,viter1578 in list(viter1576.items()):
          oprot.writeString(kiter1577)
          oprot.writeSetBegin(TType.STRUCT, len(viter1578))
          for iter1579 in viter1578:
            iter1579.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1583, _size1580) = iprot.readListBegin()
          for _i1584 in range(_size1580):
            _elem1585 = iprot.readString()
            self.keys.append(_elem1585)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1586 in self.keys:
        oprot.writeString(iter1586)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1588, _vtype1589, _size1587 ) = iprot.readMapBegin()
          for _i1591 in range(_size1587):
            _key1592 = iprot.readI64()
            _val1593 = {}
            (_ktype1595, _vtype1596, _size1594 ) = iprot.readMapBegin()
            for _i1598 in range(_size1594):
              _key1599 = iprot.readString()
              _val1600 = []
              (_etype1604, _size1601) = iprot.readSetBegin()
              for _i1605 in range(_size1601):
                _elem1606 = TObject()
                _elem1606.read(iprot)
                _val1600.append(_elem1606)
              iprot.readSetEnd()
              _val1593[_key1599] = _val1600
            iprot.readMapEnd()
            self.success[_key1592] = _val1593
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1607,viter1608 in list(self.success.items()):
        oprot.writeI64(kiter1607)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1608))
        for kiter1609,viter1610 in list(viter1608.items()):
          oprot.writeString(kiter1609)
          oprot.writeSetBegin(TType.STRUCT, len(viter1610))
          for iter1611 in viter1610:
            iter1611.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1615, _size1612) = iprot.readListBegin()
          for _i1616 in range(_size1612):
            _elem1617 = iprot.readString()
            self.keys.append(_elem1617)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1618 in self.keys:
        oprot.writeString(iter1618)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class selectKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.SET,(TType.STRUCT,(TObject, TObject.thrift_spec)))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1620, _vtype1621, _size1619 ) = iprot.readMapBegin()
          for _i1623 in range(_size1619):
            _key1624 = iprot.readI64()
            _val1625 = {}
            (_ktype1627, _vtype1628, _size1626 ) = iprot.readMapBegin()
            for _i1630 in range(_size1626):
              _key1631 = iprot.readString()
              _val1632 = []
              (_etype1636, _size1633) = iprot.readSetBegin()
              for _i1637 in range(_size1633):
                _elem1638 = TObject()
                _elem1638.read(iprot)
                _val1632.append(_elem1638)
              iprot.readSetEnd()
              _val1625[_key1631] = _val1632
            iprot.readMapEnd()
            self.success[_key1624] = _val1625
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('selectKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1639,viter1640 in list(self.success.items()):
        oprot.writeI64(kiter1639)
        oprot.writeMapBegin(TType.STRING, TType.SET, len(viter1640))
        for kiter1641,viter1642 in list(viter1640.items()):
          oprot.writeString(kiter1641)
          oprot.writeSetBegin(TType.STRUCT, len(viter1642))
          for iter1643 in viter1642:
            iter1643.write(oprot)
          oprot.writeSetEnd()
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecord_args:
  """
  Attributes:
   - key
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TObject, TObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecord_args:
  """
  Attributes:
   - keys
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, record=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1647, _size1644) = iprot.readListBegin()
          for _i1648 in range(_size1644):
            _elem1649 = iprot.readString()
            self.keys.append(_elem1649)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecord_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1650 in self.keys:
        oprot.writeString(iter1650)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1652, _vtype1653, _size1651 ) = iprot.readMapBegin()
          for _i1655 in range(_size1651):
            _key1656 = iprot.readString()
            _val1657 = TObject()
            _val1657.read(iprot)
            self.success[_key1656] = _val1657
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1658,viter1659 in list(self.success.items()):
        oprot.writeString(kiter1658)
        viter1659.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1663, _size1660) = iprot.readListBegin()
          for _i1664 in range(_size1660):
            _elem1665 = iprot.readString()
            self.keys.append(_elem1665)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1666 in self.keys:
        oprot.writeString(iter1666)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1668, _vtype1669, _size1667 ) = iprot.readMapBegin()
          for _i1671 in range(_size1667):
            _key1672 = iprot.readString()
            _val1673 = TObject()
            _val1673.read(iprot)
            self.success[_key1672] = _val1673
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1674,viter1675 in list(self.success.items()):
        oprot.writeString(kiter1674)
        viter1675.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1679, _size1676) = iprot.readListBegin()
          for _i1680 in range(_size1676):
            _elem1681 = iprot.readString()
            self.keys.append(_elem1681)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1682 in self.keys:
        oprot.writeString(iter1682)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1684, _vtype1685, _size1683 ) = iprot.readMapBegin()
          for _i1687 in range(_size1683):
            _key1688 = iprot.readString()
            _val1689 = TObject()
            _val1689.read(iprot)
            self.success[_key1688] = _val1689
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter1690,viter1691 in list(self.success.items()):
        oprot.writeString(kiter1690)
        viter1691.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecords_args:
  """
  Attributes:
   - keys
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, records=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1695, _size1692) = iprot.readListBegin()
          for _i1696 in range(_size1692):
            _elem1697 = iprot.readString()
            self.keys.append(_elem1697)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1701, _size1698) = iprot.readListBegin()
          for _i1702 in range(_size1698):
            _elem1703 = iprot.readI64()
            self.records.append(_elem1703)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecords_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1704 in self.keys:
        oprot.writeString(iter1704)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1705 in self.records:
        oprot.writeI64(iter1705)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1707, _vtype1708, _size1706 ) = iprot.readMapBegin()
          for _i1710 in range(_size1706):
            _key1711 = iprot.readI64()
            _val1712 = {}
            (_ktype1714, _vtype1715, _size1713 ) = iprot.readMapBegin()
            for _i1717 in range(_size1713):
              _key1718 = iprot.readString()
              _val1719 = TObject()
              _val1719.read(iprot)
              _val1712[_key1718] = _val1719
            iprot.readMapEnd()
            self.success[_key1711] = _val1712
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1720,viter1721 in list(self.success.items()):
        oprot.writeI64(kiter1720)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1721))
        for kiter1722,viter1723 in list(viter1721.items()):
          oprot.writeString(kiter1722)
          viter1723.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecords_args:
  """
  Attributes:
   - key
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, records=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1727, _size1724) = iprot.readListBegin()
          for _i1728 in range(_size1724):
            _elem1729 = iprot.readI64()
            self.records.append(_elem1729)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecords_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1730 in self.records:
        oprot.writeI64(iter1730)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1732, _vtype1733, _size1731 ) = iprot.readMapBegin()
          for _i1735 in range(_size1731):
            _key1736 = iprot.readI64()
            _val1737 = TObject()
            _val1737.read(iprot)
            self.success[_key1736] = _val1737
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1738,viter1739 in list(self.success.items()):
        oprot.writeI64(kiter1738)
        viter1739.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1743, _size1740) = iprot.readListBegin()
          for _i1744 in range(_size1740):
            _elem1745 = iprot.readI64()
            self.records.append(_elem1745)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1746 in self.records:
        oprot.writeI64(iter1746)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1748, _vtype1749, _size1747 ) = iprot.readMapBegin()
          for _i1751 in range(_size1747):
            _key1752 = iprot.readI64()
            _val1753 = TObject()
            _val1753.read(iprot)
            self.success[_key1752] = _val1753
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1754,viter1755 in list(self.success.items()):
        oprot.writeI64(kiter1754)
        viter1755.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1759, _size1756) = iprot.readListBegin()
          for _i1760 in range(_size1756):
            _elem1761 = iprot.readI64()
            self.records.append(_elem1761)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1762 in self.records:
        oprot.writeI64(iter1762)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1764, _vtype1765, _size1763 ) = iprot.readMapBegin()
          for _i1767 in range(_size1763):
            _key1768 = iprot.readI64()
            _val1769 = TObject()
            _val1769.read(iprot)
            self.success[_key1768] = _val1769
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1770,viter1771 in list(self.success.items()):
        oprot.writeI64(kiter1770)
        viter1771.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1775, _size1772) = iprot.readListBegin()
          for _i1776 in range(_size1772):
            _elem1777 = iprot.readString()
            self.keys.append(_elem1777)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1781, _size1778) = iprot.readListBegin()
          for _i1782 in range(_size1778):
            _elem1783 = iprot.readI64()
            self.records.append(_elem1783)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1784 in self.keys:
        oprot.writeString(iter1784)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1785 in self.records:
        oprot.writeI64(iter1785)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1787, _vtype1788, _size1786 ) = iprot.readMapBegin()
          for _i1790 in range(_size1786):
            _key1791 = iprot.readI64()
            _val1792 = {}
            (_ktype1794, _vtype1795, _size1793 ) = iprot.readMapBegin()
            for _i1797 in range(_size1793):
              _key1798 = iprot.readString()
              _val1799 = TObject()
              _val1799.read(iprot)
              _val1792[_key1798] = _val1799
            iprot.readMapEnd()
            self.success[_key1791] = _val1792
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1800,viter1801 in list(self.success.items()):
        oprot.writeI64(kiter1800)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1801))
        for kiter1802,viter1803 in list(viter1801.items()):
          oprot.writeString(kiter1802)
          viter1803.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype1807, _size1804) = iprot.readListBegin()
          for _i1808 in range(_size1804):
            _elem1809 = iprot.readString()
            self.keys.append(_elem1809)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype1813, _size1810) = iprot.readListBegin()
          for _i1814 in range(_size1810):
            _elem1815 = iprot.readI64()
            self.records.append(_elem1815)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter1816 in self.keys:
        oprot.writeString(iter1816)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter1817 in self.records:
        oprot.writeI64(iter1817)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1819, _vtype1820, _size1818 ) = iprot.readMapBegin()
          for _i1822 in range(_size1818):
            _key1823 = iprot.readI64()
            _val1824 = {}
            (_ktype1826, _vtype1827, _size1825 ) = iprot.readMapBegin()
            for _i1829 in range(_size1825):
              _key1830 = iprot.readString()
              _val1831 = TObject()
              _val1831.read(iprot)
              _val1824[_key1830] = _val1831
            iprot.readMapEnd()
            self.success[_key1823] = _val1824
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1832,viter1833 in list(self.success.items()):
        oprot.writeI64(kiter1832)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1833))
        for kiter1834,viter1835 in list(viter1833.items()):
          oprot.writeString(kiter1834)
          viter1835.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteria_args:
  """
  Attributes:
   - key
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteria_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1837, _vtype1838, _size1836 ) = iprot.readMapBegin()
          for _i1840 in range(_size1836):
            _key1841 = iprot.readI64()
            _val1842 = TObject()
            _val1842.read(iprot)
            self.success[_key1841] = _val1842
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1843,viter1844 in list(self.success.items()):
        oprot.writeI64(kiter1843)
        viter1844.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1846, _vtype1847, _size1845 ) = iprot.readMapBegin()
          for _i1849 in range(_size1845):
            _key1850 = iprot.readI64()
            _val1851 = {}
            (_ktype1853, _vtype1854, _size1852 ) = iprot.readMapBegin()
            for _i1856 in range(_size1852):
              _key1857 = iprot.readString()
              _val1858 = TObject()
              _val1858.read(iprot)
              _val1851[_key1857] = _val1858
            iprot.readMapEnd()
            self.success[_key1850] = _val1851
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1859,viter1860 in list(self.success.items()):
        oprot.writeI64(kiter1859)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1860))
        for kiter1861,viter1862 in list(viter1860.items()):
          oprot.writeString(kiter1861)
          viter1862.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1864, _vtype1865, _size1863 ) = iprot.readMapBegin()
          for _i1867 in range(_size1863):
            _key1868 = iprot.readI64()
            _val1869 = {}
            (_ktype1871, _vtype1872, _size1870 ) = iprot.readMapBegin()
            for _i1874 in range(_size1870):
              _key1875 = iprot.readString()
              _val1876 = TObject()
              _val1876.read(iprot)
              _val1869[_key1875] = _val1876
            iprot.readMapEnd()
            self.success[_key1868] = _val1869
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1877,viter1878 in list(self.success.items()):
        oprot.writeI64(kiter1877)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1878))
        for kiter1879,viter1880 in list(viter1878.items()):
          oprot.writeString(kiter1879)
          viter1880.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTime_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTime_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1882, _vtype1883, _size1881 ) = iprot.readMapBegin()
          for _i1885 in range(_size1881):
            _key1886 = iprot.readI64()
            _val1887 = {}
            (_ktype1889, _vtype1890, _size1888 ) = iprot.readMapBegin()
            for _i1892 in range(_size1888):
              _key1893 = iprot.readString()
              _val1894 = TObject()
              _val1894.read(iprot)
              _val1887[_key1893] = _val1894
            iprot.readMapEnd()
            self.success[_key1886] = _val1887
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1895,viter1896 in list(self.success.items()):
        oprot.writeI64(kiter1895)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1896))
        for kiter1897,viter1898 in list(viter1896.items()):
          oprot.writeString(kiter1897)
          viter1898.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTimestr_args:
  """
  Attributes:
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTimestr_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1900, _vtype1901, _size1899 ) = iprot.readMapBegin()
          for _i1903 in range(_size1899):
            _key1904 = iprot.readI64()
            _val1905 = {}
            (_ktype1907, _vtype1908, _size1906 ) = iprot.readMapBegin()
            for _i1910 in range(_size1906):
              _key1911 = iprot.readString()
              _val1912 = TObject()
              _val1912.read(iprot)
              _val1905[_key1911] = _val1912
            iprot.readMapEnd()
            self.success[_key1904] = _val1905
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1913,viter1914 in list(self.success.items()):
        oprot.writeI64(kiter1913)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1914))
        for kiter1915,viter1916 in list(viter1914.items()):
          oprot.writeString(kiter1915)
          viter1916.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTime_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTime_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1918, _vtype1919, _size1917 ) = iprot.readMapBegin()
          for _i1921 in range(_size1917):
            _key1922 = iprot.readI64()
            _val1923 = {}
            (_ktype1925, _vtype1926, _size1924 ) = iprot.readMapBegin()
            for _i1928 in range(_size1924):
              _key1929 = iprot.readString()
              _val1930 = TObject()
              _val1930.read(iprot)
              _val1923[_key1929] = _val1930
            iprot.readMapEnd()
            self.success[_key1922] = _val1923
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1931,viter1932 in list(self.success.items()):
        oprot.writeI64(kiter1931)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1932))
        for kiter1933,viter1934 in list(viter1932.items()):
          oprot.writeString(kiter1933)
          viter1934.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTimestr_args:
  """
  Attributes:
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTimestr_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1936, _vtype1937, _size1935 ) = iprot.readMapBegin()
          for _i1939 in range(_size1935):
            _key1940 = iprot.readI64()
            _val1941 = {}
            (_ktype1943, _vtype1944, _size1942 ) = iprot.readMapBegin()
            for _i1946 in range(_size1942):
              _key1947 = iprot.readString()
              _val1948 = TObject()
              _val1948.read(iprot)
              _val1941[_key1947] = _val1948
            iprot.readMapEnd()
            self.success[_key1940] = _val1941
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter1949,viter1950 in list(self.success.items()):
        oprot.writeI64(kiter1949)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter1950))
        for kiter1951,viter1952 in list(viter1950.items()):
          oprot.writeString(kiter1951)
          viter1952.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCcl_args:
  """
  Attributes:
   - key
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCcl_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1954, _vtype1955, _size1953 ) = iprot.readMapBegin()
          for _i1957 in range(_size1953):
            _key1958 = iprot.readI64()
            _val1959 = TObject()
            _val1959.read(iprot)
            self.success[_key1958] = _val1959
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1960,viter1961 in list(self.success.items()):
        oprot.writeI64(kiter1960)
        viter1961.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTime_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1963, _vtype1964, _size1962 ) = iprot.readMapBegin()
          for _i1966 in range(_size1962):
            _key1967 = iprot.readI64()
            _val1968 = TObject()
            _val1968.read(iprot)
            self.success[_key1967] = _val1968
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1969,viter1970 in list(self.success.items()):
        oprot.writeI64(kiter1969)
        viter1970.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTimestr_args:
  """
  Attributes:
   - key
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1972, _vtype1973, _size1971 ) = iprot.readMapBegin()
          for _i1975 in range(_size1971):
            _key1976 = iprot.readI64()
            _val1977 = TObject()
            _val1977.read(iprot)
            self.success[_key1976] = _val1977
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1978,viter1979 in list(self.success.items()):
        oprot.writeI64(kiter1978)
        viter1979.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTime_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1981, _vtype1982, _size1980 ) = iprot.readMapBegin()
          for _i1984 in range(_size1980):
            _key1985 = iprot.readI64()
            _val1986 = TObject()
            _val1986.read(iprot)
            self.success[_key1985] = _val1986
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1987,viter1988 in list(self.success.items()):
        oprot.writeI64(kiter1987)
        viter1988.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTimestr_args:
  """
  Attributes:
   - key
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeyCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype1990, _vtype1991, _size1989 ) = iprot.readMapBegin()
          for _i1993 in range(_size1989):
            _key1994 = iprot.readI64()
            _val1995 = TObject()
            _val1995.read(iprot)
            self.success[_key1994] = _val1995
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeyCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.success))
      for kiter1996,viter1997 in list(self.success.items()):
        oprot.writeI64(kiter1996)
        viter1997.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteria_args:
  """
  Attributes:
   - keys
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, criteria=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2001, _size1998) = iprot.readListBegin()
          for _i2002 in range(_size1998):
            _elem2003 = iprot.readString()
            self.keys.append(_elem2003)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteria_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2004 in self.keys:
        oprot.writeString(iter2004)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2006, _vtype2007, _size2005 ) = iprot.readMapBegin()
          for _i2009 in range(_size2005):
            _key2010 = iprot.readI64()
            _val2011 = {}
            (_ktype2013, _vtype2014, _size2012 ) = iprot.readMapBegin()
            for _i2016 in range(_size2012):
              _key2017 = iprot.readString()
              _val2018 = TObject()
              _val2018.read(iprot)
              _val2011[_key2017] = _val2018
            iprot.readMapEnd()
            self.success[_key2010] = _val2011
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2019,viter2020 in list(self.success.items()):
        oprot.writeI64(kiter2019)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2020))
        for kiter2021,viter2022 in list(viter2020.items()):
          oprot.writeString(kiter2021)
          viter2022.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCcl_args:
  """
  Attributes:
   - keys
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, keys=None, ccl=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2026, _size2023) = iprot.readListBegin()
          for _i2027 in range(_size2023):
            _elem2028 = iprot.readString()
            self.keys.append(_elem2028)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCcl_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2029 in self.keys:
        oprot.writeString(iter2029)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2031, _vtype2032, _size2030 ) = iprot.readMapBegin()
          for _i2034 in range(_size2030):
            _key2035 = iprot.readI64()
            _val2036 = {}
            (_ktype2038, _vtype2039, _size2037 ) = iprot.readMapBegin()
            for _i2041 in range(_size2037):
              _key2042 = iprot.readString()
              _val2043 = TObject()
              _val2043.read(iprot)
              _val2036[_key2042] = _val2043
            iprot.readMapEnd()
            self.success[_key2035] = _val2036
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2044,viter2045 in list(self.success.items()):
        oprot.writeI64(kiter2044)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2045))
        for kiter2046,viter2047 in list(viter2045.items()):
          oprot.writeString(kiter2046)
          viter2047.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTime_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2051, _size2048) = iprot.readListBegin()
          for _i2052 in range(_size2048):
            _elem2053 = iprot.readString()
            self.keys.append(_elem2053)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2054 in self.keys:
        oprot.writeString(iter2054)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2056, _vtype2057, _size2055 ) = iprot.readMapBegin()
          for _i2059 in range(_size2055):
            _key2060 = iprot.readI64()
            _val2061 = {}
            (_ktype2063, _vtype2064, _size2062 ) = iprot.readMapBegin()
            for _i2066 in range(_size2062):
              _key2067 = iprot.readString()
              _val2068 = TObject()
              _val2068.read(iprot)
              _val2061[_key2067] = _val2068
            iprot.readMapEnd()
            self.success[_key2060] = _val2061
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2069,viter2070 in list(self.success.items()):
        oprot.writeI64(kiter2069)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2070))
        for kiter2071,viter2072 in list(viter2070.items()):
          oprot.writeString(kiter2071)
          viter2072.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTimestr_args:
  """
  Attributes:
   - keys
   - criteria
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, criteria=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.criteria = criteria
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2076, _size2073) = iprot.readListBegin()
          for _i2077 in range(_size2073):
            _elem2078 = iprot.readString()
            self.keys.append(_elem2078)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2079 in self.keys:
        oprot.writeString(iter2079)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 2)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCriteriaTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2081, _vtype2082, _size2080 ) = iprot.readMapBegin()
          for _i2084 in range(_size2080):
            _key2085 = iprot.readI64()
            _val2086 = {}
            (_ktype2088, _vtype2089, _size2087 ) = iprot.readMapBegin()
            for _i2091 in range(_size2087):
              _key2092 = iprot.readString()
              _val2093 = TObject()
              _val2093.read(iprot)
              _val2086[_key2092] = _val2093
            iprot.readMapEnd()
            self.success[_key2085] = _val2086
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCriteriaTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2094,viter2095 in list(self.success.items()):
        oprot.writeI64(kiter2094)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2095))
        for kiter2096,viter2097 in list(viter2095.items()):
          oprot.writeString(kiter2096)
          viter2097.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTime_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2101, _size2098) = iprot.readListBegin()
          for _i2102 in range(_size2098):
            _elem2103 = iprot.readString()
            self.keys.append(_elem2103)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2104 in self.keys:
        oprot.writeString(iter2104)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2106, _vtype2107, _size2105 ) = iprot.readMapBegin()
          for _i2109 in range(_size2105):
            _key2110 = iprot.readI64()
            _val2111 = {}
            (_ktype2113, _vtype2114, _size2112 ) = iprot.readMapBegin()
            for _i2116 in range(_size2112):
              _key2117 = iprot.readString()
              _val2118 = TObject()
              _val2118.read(iprot)
              _val2111[_key2117] = _val2118
            iprot.readMapEnd()
            self.success[_key2110] = _val2111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2119,viter2120 in list(self.success.items()):
        oprot.writeI64(kiter2119)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2120))
        for kiter2121,viter2122 in list(viter2120.items()):
          oprot.writeString(kiter2121)
          viter2122.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTimestr_args:
  """
  Attributes:
   - keys
   - ccl
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'ccl', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, ccl=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.ccl = ccl
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2126, _size2123) = iprot.readListBegin()
          for _i2127 in range(_size2123):
            _elem2128 = iprot.readString()
            self.keys.append(_elem2128)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2129 in self.keys:
        oprot.writeString(iter2129)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 2)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getKeysCclTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.STRING,None,TType.STRUCT,(TObject, TObject.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2131, _vtype2132, _size2130 ) = iprot.readMapBegin()
          for _i2134 in range(_size2130):
            _key2135 = iprot.readI64()
            _val2136 = {}
            (_ktype2138, _vtype2139, _size2137 ) = iprot.readMapBegin()
            for _i2141 in range(_size2137):
              _key2142 = iprot.readString()
              _val2143 = TObject()
              _val2143.read(iprot)
              _val2136[_key2142] = _val2143
            iprot.readMapEnd()
            self.success[_key2135] = _val2136
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getKeysCclTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter2144,viter2145 in list(self.success.items()):
        oprot.writeI64(kiter2144)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter2145))
        for kiter2146,viter2147 in list(viter2145.items()):
          oprot.writeString(kiter2146)
          viter2147.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecord_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecord_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTime_args:
  """
  Attributes:
   - key
   - value
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTimestr_args:
  """
  Attributes:
   - key
   - value
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, value=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyKeyValueRecordTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyKeyValueRecordTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecords_args:
  """
  Attributes:
   - records
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.BOOL, 'identifier', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, records=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2151, _size2148) = iprot.readListBegin()
          for _i2152 in range(_size2148):
            _elem2153 = iprot.readI64()
            self.records.append(_elem2153)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2154 in self.records:
        oprot.writeI64(iter2154)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 2)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTime_args:
  """
  Attributes:
   - records
   - timestamp
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.BOOL, 'identifier', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2158, _size2155) = iprot.readListBegin()
          for _i2159 in range(_size2155):
            _elem2160 = iprot.readI64()
            self.records.append(_elem2160)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTime_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2161 in self.records:
        oprot.writeI64(iter2161)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 3)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTimestr_args:
  """
  Attributes:
   - records
   - timestamp
   - identifier
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRING, 'timestamp', None, None, ), # 2
    (3, TType.BOOL, 'identifier', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, records=None, timestamp=None, identifier=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.timestamp = timestamp
    self.identifier = identifier
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2165, _size2162) = iprot.readListBegin()
          for _i2166 in range(_size2162):
            _elem2167 = iprot.readI64()
            self.records.append(_elem2167)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.identifier = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTimestr_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2168 in self.records:
        oprot.writeI64(iter2168)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 2)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.identifier is not None:
      oprot.writeFieldBegin('identifier', TType.BOOL, 3)
      oprot.writeBool(self.identifier)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.identifier)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class jsonifyRecordsTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('jsonifyRecordsTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCriteria_args:
  """
  Attributes:
   - criteria
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, criteria=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCriteria_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCriteria_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2172, _size2169) = iprot.readSetBegin()
          for _i2173 in range(_size2169):
            _elem2174 = iprot.readI64()
            self.success.append(_elem2174)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCriteria_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2175 in self.success:
        oprot.writeI64(iter2175)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCcl_args:
  """
  Attributes:
   - ccl
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, ccl=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCcl_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findCcl_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2179, _size2176) = iprot.readSetBegin()
          for _i2180 in range(_size2176):
            _elem2181 = iprot.readI64()
            self.success.append(_elem2181)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findCcl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2182 in self.success:
        oprot.writeI64(iter2182)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValues_args:
  """
  Attributes:
   - key
   - operator
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2186, _size2183) = iprot.readListBegin()
          for _i2187 in range(_size2183):
            _elem2188 = TObject()
            _elem2188.read(iprot)
            self.values.append(_elem2188)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2189 in self.values:
        iter2189.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValues_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2193, _size2190) = iprot.readSetBegin()
          for _i2194 in range(_size2190):
            _elem2195 = iprot.readI64()
            self.success.append(_elem2195)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2196 in self.success:
        oprot.writeI64(iter2196)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTime_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2200, _size2197) = iprot.readListBegin()
          for _i2201 in range(_size2197):
            _elem2202 = TObject()
            _elem2202.read(iprot)
            self.values.append(_elem2202)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2203 in self.values:
        iter2203.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2207, _size2204) = iprot.readSetBegin()
          for _i2208 in range(_size2204):
            _elem2209 = iprot.readI64()
            self.success.append(_elem2209)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2210 in self.success:
        oprot.writeI64(iter2210)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTimestr_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I32, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.operator = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2214, _size2211) = iprot.readListBegin()
          for _i2215 in range(_size2211):
            _elem2216 = TObject()
            _elem2216.read(iprot)
            self.values.append(_elem2216)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.I32, 2)
      oprot.writeI32(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2217 in self.values:
        iter2217.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorValuesTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2221, _size2218) = iprot.readSetBegin()
          for _i2222 in range(_size2218):
            _elem2223 = iprot.readI64()
            self.success.append(_elem2223)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorValuesTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2224 in self.success:
        oprot.writeI64(iter2224)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValues_args:
  """
  Attributes:
   - key
   - operator
   - values
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, operator=None, values=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2228, _size2225) = iprot.readListBegin()
          for _i2229 in range(_size2225):
            _elem2230 = TObject()
            _elem2230.read(iprot)
            self.values.append(_elem2230)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValues_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2231 in self.values:
        iter2231.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValues_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2235, _size2232) = iprot.readSetBegin()
          for _i2236 in range(_size2232):
            _elem2237 = iprot.readI64()
            self.success.append(_elem2237)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValues_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2238 in self.success:
        oprot.writeI64(iter2238)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTime_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2242, _size2239) = iprot.readListBegin()
          for _i2243 in range(_size2239):
            _elem2244 = TObject()
            _elem2244.read(iprot)
            self.values.append(_elem2244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2245 in self.values:
        iter2245.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTime_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2249, _size2246) = iprot.readSetBegin()
          for _i2250 in range(_size2246):
            _elem2251 = iprot.readI64()
            self.success.append(_elem2251)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTime_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2252 in self.success:
        oprot.writeI64(iter2252)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTimestr_args:
  """
  Attributes:
   - key
   - operator
   - values
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'operator', None, None, ), # 2
    (3, TType.LIST, 'values', (TType.STRUCT,(TObject, TObject.thrift_spec)), None, ), # 3
    (4, TType.STRING, 'timestamp', None, None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, operator=None, values=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.operator = operator
    self.values = values
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.operator = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype2256, _size2253) = iprot.readListBegin()
          for _i2257 in range(_size2253):
            _elem2258 = TObject()
            _elem2258.read(iprot)
            self.values.append(_elem2258)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.operator is not None:
      oprot.writeFieldBegin('operator', TType.STRING, 2)
      oprot.writeString(self.operator)
      oprot.writeFieldEnd()
    if self.values is not None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter2259 in self.values:
        iter2259.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 4)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.operator)
    value = (value * 31) ^ hash(self.values)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findKeyOperatorstrValuesTimestr_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2263, _size2260) = iprot.readSetBegin()
          for _i2264 in range(_size2260):
            _elem2265 = iprot.readI64()
            self.success.append(_elem2265)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findKeyOperatorstrValuesTimestr_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2266 in self.success:
        oprot.writeI64(iter2266)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_args:
  """
  Attributes:
   - key
   - query
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'query', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, query=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.query = query
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.query = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 2)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.query)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = []
          (_etype2270, _size2267) = iprot.readSetBegin()
          for _i2271 in range(_size2267):
            _elem2272 = iprot.readI64()
            self.success.append(_elem2272)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I64, len(self.success))
      for iter2273 in self.success:
        oprot.writeI64(iter2273)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTime_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2277, _size2274) = iprot.readListBegin()
          for _i2278 in range(_size2274):
            _elem2279 = iprot.readString()
            self.keys.append(_elem2279)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2283, _size2280) = iprot.readListBegin()
          for _i2284 in range(_size2280):
            _elem2285 = iprot.readI64()
            self.records.append(_elem2285)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2286 in self.keys:
        oprot.writeString(iter2286)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2287 in self.records:
        oprot.writeI64(iter2287)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTimestr_args:
  """
  Attributes:
   - keys
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2291, _size2288) = iprot.readListBegin()
          for _i2292 in range(_size2288):
            _elem2293 = iprot.readString()
            self.keys.append(_elem2293)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2297, _size2294) = iprot.readListBegin()
          for _i2298 in range(_size2294):
            _elem2299 = iprot.readI64()
            self.records.append(_elem2299)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2300 in self.keys:
        oprot.writeString(iter2300)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2301 in self.records:
        oprot.writeI64(iter2301)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordsTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordsTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTime_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2305, _size2302) = iprot.readListBegin()
          for _i2306 in range(_size2302):
            _elem2307 = iprot.readString()
            self.keys.append(_elem2307)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTime_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2308 in self.keys:
        oprot.writeString(iter2308)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTimestr_args:
  """
  Attributes:
   - keys
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'keys', (TType.STRING,None), None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, keys=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.keys = keys
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype2312, _size2309) = iprot.readListBegin()
          for _i2313 in range(_size2309):
            _elem2314 = iprot.readString()
            self.keys.append(_elem2314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTimestr_args')
    if self.keys is not None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter2315 in self.keys:
        oprot.writeString(iter2315)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.keys)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeysRecordTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeysRecordTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTime_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2319, _size2316) = iprot.readListBegin()
          for _i2320 in range(_size2316):
            _elem2321 = iprot.readI64()
            self.records.append(_elem2321)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2322 in self.records:
        oprot.writeI64(iter2322)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTimestr_args:
  """
  Attributes:
   - key
   - records
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.LIST, 'records', (TType.I64,None), None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, records=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.records = records
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype2326, _size2323) = iprot.readListBegin()
          for _i2327 in range(_size2323):
            _elem2328 = iprot.readI64()
            self.records.append(_elem2328)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2329 in self.records:
        oprot.writeI64(iter2329)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordsTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordsTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTime_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTime_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTime_result:
  """
  Attributes:
   - ex
   - ex2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, ex=None, ex2=None,):
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTime_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTimestr_args:
  """
  Attributes:
   - key
   - record
   - timestamp
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.I64, 'record', None, None, ), # 2
    (3, TType.STRING, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, record=None, timestamp=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.record = record
    self.timestamp = timestamp
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.timestamp = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTimestr_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 2)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.STRING, 3)
      oprot.writeString(self.timestamp)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class revertKeyRecordTimestr_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('revertKeyRecordTimestr_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecords_args:
  """
  Attributes:
   - records
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.I64,None), None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, records=None, creds=None, transaction=None, environment=None,):
    self.records = records
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype2333, _size2330) = iprot.readListBegin()
          for _i2334 in range(_size2330):
            _elem2335 = iprot.readI64()
            self.records.append(_elem2335)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecords_args')
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.records))
      for iter2336 in self.records:
        oprot.writeI64(iter2336)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.records)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecords_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.BOOL,None), None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype2338, _vtype2339, _size2337 ) = iprot.readMapBegin()
          for _i2341 in range(_size2337):
            _key2342 = iprot.readI64()
            _val2343 = iprot.readBool()
            self.success[_key2342] = _val2343
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.BOOL, len(self.success))
      for kiter2344,viter2345 in list(self.success.items()):
        oprot.writeI64(kiter2344)
        oprot.writeBool(viter2345)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecord_args:
  """
  Attributes:
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'record', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, record=None, creds=None, transaction=None, environment=None,):
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecord_args')
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 1)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 3)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class pingRecord_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('pingRecord_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyAndSwap_args:
  """
  Attributes:
   - key
   - expected
   - record
   - replacement
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'expected', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'replacement', (TObject, TObject.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 6
    (7, TType.STRING, 'environment', None, None, ), # 7
  )

  def __init__(self, key=None, expected=None, record=None, replacement=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.expected = expected
    self.record = record
    self.replacement = replacement
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.expected = TObject()
          self.expected.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.replacement = TObject()
          self.replacement.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyAndSwap_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.expected is not None:
      oprot.writeFieldBegin('expected', TType.STRUCT, 2)
      self.expected.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.replacement is not None:
      oprot.writeFieldBegin('replacement', TType.STRUCT, 4)
      self.replacement.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 5)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 6)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 7)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.expected)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.replacement)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyAndSwap_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyAndSwap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyOrSet_args:
  """
  Attributes:
   - key
   - value
   - record
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.I64, 'record', None, None, ), # 3
    (4, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 5
    (6, TType.STRING, 'environment', None, None, ), # 6
  )

  def __init__(self, key=None, value=None, record=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.record = record
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.record = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyOrSet_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.record is not None:
      oprot.writeFieldBegin('record', TType.I64, 3)
      oprot.writeI64(self.record)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 4)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 5)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 6)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.record)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class verifyOrSet_result:
  """
  Attributes:
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 3
  )

  def __init__(self, ex=None, ex2=None, ex3=None,):
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = InvalidArgumentException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('verifyOrSet_result')
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrAddKeyValue_args:
  """
  Attributes:
   - key
   - value
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRUCT, 'value', (TObject, TObject.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, key=None, value=None, creds=None, transaction=None, environment=None,):
    self.key = key
    self.value = value
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.value = TObject()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrAddKeyValue_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRUCT, 2)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.key)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrAddKeyValue_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
   - ex4
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex4', (InvalidArgumentException, InvalidArgumentException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3
    self.ex4 = ex4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = DuplicateEntryException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex4 = InvalidArgumentException()
          self.ex4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrAddKeyValue_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    if self.ex4 is not None:
      oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
      self.ex4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    value = (value * 31) ^ hash(self.ex4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCriteriaJson_args:
  """
  Attributes:
   - criteria
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'criteria', (TCriteria, TCriteria.thrift_spec), None, ), # 1
    (2, TType.STRING, 'json', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, criteria=None, json=None, creds=None, transaction=None, environment=None,):
    self.criteria = criteria
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.criteria = TCriteria()
          self.criteria.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCriteriaJson_args')
    if self.criteria is not None:
      oprot.writeFieldBegin('criteria', TType.STRUCT, 1)
      self.criteria.write(oprot)
      oprot.writeFieldEnd()
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 2)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.criteria)
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCriteriaJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = DuplicateEntryException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCriteriaJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCclJson_args:
  """
  Attributes:
   - ccl
   - json
   - creds
   - transaction
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ccl', None, None, ), # 1
    (2, TType.STRING, 'json', None, None, ), # 2
    (3, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'transaction', (TransactionToken, TransactionToken.thrift_spec), None, ), # 4
    (5, TType.STRING, 'environment', None, None, ), # 5
  )

  def __init__(self, ccl=None, json=None, creds=None, transaction=None, environment=None,):
    self.ccl = ccl
    self.json = json
    self.creds = creds
    self.transaction = transaction
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ccl = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.json = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transaction = TransactionToken()
          self.transaction.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCclJson_args')
    if self.ccl is not None:
      oprot.writeFieldBegin('ccl', TType.STRING, 1)
      oprot.writeString(self.ccl)
      oprot.writeFieldEnd()
    if self.json is not None:
      oprot.writeFieldBegin('json', TType.STRING, 2)
      oprot.writeString(self.json)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 3)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.transaction is not None:
      oprot.writeFieldBegin('transaction', TType.STRUCT, 4)
      self.transaction.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 5)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ccl)
    value = (value * 31) ^ hash(self.json)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.transaction)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class findOrInsertCclJson_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
   - ex4
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ex4', (DuplicateEntryException, DuplicateEntryException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None, ex4=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3
    self.ex4 = ex4

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ex4 = DuplicateEntryException()
          self.ex4.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('findOrInsertCclJson_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    if self.ex4 is not None:
      oprot.writeFieldBegin('ex4', TType.STRUCT, 4)
      self.ex4.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    value = (value * 31) ^ hash(self.ex4)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerEnvironment_args:
  """
  Attributes:
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, token=None, environment=None,):
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerEnvironment_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 2)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerEnvironment_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerEnvironment_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerVersion_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerVersion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_args:
  """
  Attributes:
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 2
    (3, TType.STRING, 'environment', None, None, ), # 3
  )

  def __init__(self, creds=None, token=None, environment=None,):
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_args')
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 1)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 2)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 3)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class time_result:
  """
  Attributes:
   - success
   - ex
   - ex2
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ex=None, ex2=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('time_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timePhrase_args:
  """
  Attributes:
   - phrase
   - creds
   - token
   - environment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'phrase', None, None, ), # 1
    (2, TType.STRUCT, 'creds', (AccessToken, AccessToken.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'token', (TransactionToken, TransactionToken.thrift_spec), None, ), # 3
    (4, TType.STRING, 'environment', None, None, ), # 4
  )

  def __init__(self, phrase=None, creds=None, token=None, environment=None,):
    self.phrase = phrase
    self.creds = creds
    self.token = token
    self.environment = environment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.phrase = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.creds = AccessToken()
          self.creds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.token = TransactionToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.environment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timePhrase_args')
    if self.phrase is not None:
      oprot.writeFieldBegin('phrase', TType.STRING, 1)
      oprot.writeString(self.phrase)
      oprot.writeFieldEnd()
    if self.creds is not None:
      oprot.writeFieldBegin('creds', TType.STRUCT, 2)
      self.creds.write(oprot)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 3)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.environment is not None:
      oprot.writeFieldBegin('environment', TType.STRING, 4)
      oprot.writeString(self.environment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.phrase)
    value = (value * 31) ^ hash(self.creds)
    value = (value * 31) ^ hash(self.token)
    value = (value * 31) ^ hash(self.environment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class timePhrase_result:
  """
  Attributes:
   - success
   - ex
   - ex2
   - ex3
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ex', (SecurityException, SecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ex2', (TransactionException, TransactionException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ex3', (ParseException, ParseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ex=None, ex2=None, ex3=None,):
    self.success = success
    self.ex = ex
    self.ex2 = ex2
    self.ex3 = ex3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ex = SecurityException()
          self.ex.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ex2 = TransactionException()
          self.ex2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ex3 = ParseException()
          self.ex3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('timePhrase_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ex is not None:
      oprot.writeFieldBegin('ex', TType.STRUCT, 1)
      self.ex.write(oprot)
      oprot.writeFieldEnd()
    if self.ex2 is not None:
      oprot.writeFieldBegin('ex2', TType.STRUCT, 2)
      self.ex2.write(oprot)
      oprot.writeFieldEnd()
    if self.ex3 is not None:
      oprot.writeFieldBegin('ex3', TType.STRUCT, 3)
      self.ex3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.ex)
    value = (value * 31) ^ hash(self.ex2)
    value = (value * 31) ^ hash(self.ex3)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.items()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
